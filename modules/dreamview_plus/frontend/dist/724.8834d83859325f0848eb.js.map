{"version":3,"file":"724.8834d83859325f0848eb.js","mappings":"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","sources":["webpack:///../../../dreamview-carviz/src/constant/common.ts","webpack:///../../../dreamview-carviz/src/render/view.ts","webpack:///../../../dreamview-carviz/src/utils/line.ts","webpack:///../../../dreamview-carviz/src/utils/common.ts","webpack:///../../../dreamview-carviz/src/render/map/lane.ts","webpack:///../../../dreamview-carviz/src/utils/polygon.ts","webpack:///../../../dreamview-carviz/src/render/map/junction.ts","webpack:///../../../dreamview-carviz/src/render/map/grid.ts","webpack:///../../../dreamview-carviz/src/utils/zone.ts","webpack:///../../../dreamview-carviz/src/render/map/clearArea.ts","webpack:///../../../dreamview-carviz/src/render/map/crosswalk.ts","webpack:///../../../dreamview-carviz/src/render/map/pncJunction.ts","webpack:///../../../dreamview-carviz/src/render/map/road.ts","webpack:///../../../dreamview-carviz/assets/models/yield_sign.mtl","webpack:///../../../dreamview-carviz/assets/models/yield_sign.obj","webpack:///../../../dreamview-carviz/src/utils/stopLine.ts","webpack:///../../../dreamview-carviz/src/utils/signal.ts","webpack:///../../../dreamview-carviz/src/render/map/yieldSignal.ts","webpack:///../../../dreamview-carviz/assets/models/traffic_light.mtl","webpack:///../../../dreamview-carviz/assets/models/traffic_light.obj","webpack:///../../../dreamview-carviz/src/render/map/trafficSignal.ts","webpack:///../../../dreamview-carviz/assets/models/stop_sign.mtl","webpack:///../../../dreamview-carviz/assets/models/stop_sign.obj","webpack:///../../../dreamview-carviz/src/render/map/stopSign.ts","webpack:///../../../dreamview-carviz/src/render/map/speedBump.ts","webpack:///../../../dreamview-carviz/src/render/map/parkingSpace.ts","webpack:///../../../dreamview-carviz/src/render/map/index.ts","webpack:///../../../dreamview-carviz/assets/models/car.mtl","webpack:///../../../dreamview-carviz/assets/models/car.obj","webpack:///../../../dreamview-carviz/src/render/adc.ts","webpack:///../../../dreamview-carviz/src/render/obstacles.ts","webpack:///../../../dreamview-carviz/src/render/text.ts","webpack:///../../../dreamview-carviz/src/render/pointCloud.ts","webpack:///../../../dreamview-carviz/src/render/routing.ts","webpack:///../../../dreamview-carviz/src/render/decision.ts","webpack:///../../../dreamview-carviz/src/render/prediction.ts","webpack:///../../../dreamview-carviz/src/constant/params.ts","webpack:///../../../dreamview-carviz/src/render/planning.ts","webpack:///../../../dreamview-carviz/src/render/gps.ts","webpack:///../../../dreamview-carviz/src/option/layerVisible.ts","webpack:///../../../dreamview-carviz/src/option/index.ts","webpack:///../../../dreamview-carviz/src/render/coordinates.ts","webpack:///../../../dreamview-carviz/src/index.ts","webpack:///../../../dreamview-core/src/components/panels/VehicleViz/ViewBtn/index.tsx","webpack:///../../../dreamview-core/src/components/panels/VehicleViz/ViewMenu/index.tsx","webpack:///../../../dreamview-core/src/components/panels/VehicleViz/util.ts"],"sourcesContent":["import iconMainStop from '../../assets/images/decision/main-stop.png';\nimport iconObjectStop from '../../assets/images/decision/object-stop.png';\nimport iconObjectFollow from '../../assets/images/decision/object-follow.png';\nimport iconObjectYield from '../../assets/images/decision/object-yield.png';\nimport iconObjectOvertake from '../../assets/images/decision/object-overtake.png';\n\nimport fenceMainStop from '../../assets/images/decision/fence-main-stop.png';\nimport fenceObjectStop from '../../assets/images/decision/fence-object-stop.png';\nimport fenceObjectFollow from '../../assets/images/decision/fence-object-follow.png';\nimport fenceObjectYield from '../../assets/images/decision/fence-object-yield.png';\nimport fenceObjectOvertake from '../../assets/images/decision/fence-object-overtake.png';\n\nimport reasonHeadVehicle from '../../assets/images/decision/head-vehicle.png';\nimport reasonDestination from '../../assets/images/decision/destination.png';\nimport reasonPedestrian from '../../assets/images/decision/pedestrian.png';\nimport reasonObstacle from '../../assets/images/decision/obstacle.png';\nimport reasonSignal from '../../assets/images/decision/signal.png';\nimport reasonStopSign from '../../assets/images/decision/stop-sign.png';\nimport reasonYieldSign from '../../assets/images/decision/yield-sign.png';\nimport reasonClearZone from '../../assets/images/decision/clear-zone.png';\nimport reasonCrosswalk from '../../assets/images/decision/crosswalk.png';\nimport reasonEmergency from '../../assets/images/decision/emergency.png';\nimport reasonNotReady from '../../assets/images/decision/not-ready.png';\nimport reasonPullover from '../../assets/images/decision/pullover.png';\n\nimport iconChangeLaneRight from '../../assets/images/decision/change-lane-right.png';\nimport iconChangeLaneLeft from '../../assets/images/decision/change-lane-left.png';\n\nexport const colorMapping = {\n    YELLOW: 0xdaa520,\n    WHITE: 0xcccccc,\n    CORAL: 0xff7f50,\n    RED: 0xff6666,\n    GREEN: 0x006400,\n    BLUE: 0x30a5ff,\n    PURE_WHITE: 0xffffff,\n    DEFAULT: 0xc0c0c0,\n    MIDWAY: 0xff7f50,\n    END: 0xffdab9,\n    PULLOVER: 0x006aff,\n};\nexport const zOffset = {\n    lane: 0.04,\n    crosswalk: 0.04,\n    junction: 0.04,\n    clearArea: 0.04,\n    pncJunction: 0.04,\n    stopLine: 0.08,\n    speedBump: 0.08,\n    parkingSpace: 0.04,\n    checkpoint: 0.04,\n    pullover: 0.12,\n    routing: 0.2,\n    prediction: 0.04,\n};\n\nexport const obstacleColorMapping = {\n    PEDESTRIAN: 0xffea00,\n    BICYCLE: 0x00dceb,\n    VEHICLE: 0x00ff3c,\n    VIRTUAL: 0x800000,\n    CIPV: 0xff9966,\n    DEFAULT: 0xff00fc,\n    TRAFFICCONE: 0xe1601c,\n    UNKNOWN: 0xa020f0,\n    UNKNOWN_MOVABLE: 0xda70d6,\n    UNKNOWN_UNMOVABLE: 0xff00ff,\n};\n\nexport const pointCloudHeightColorMapping = {\n    0.5: 0xff0000,\n    1.0: 0xff7f00,\n    1.5: 0xffff00,\n    2.0: 0x00ff00,\n    2.5: 0x0000ff,\n    3.0: 0x4b0082,\n    10.0: 0x9400d3,\n};\n\nexport const decisionMarkerColorMapping = {\n    STOP: 0xff3030,\n    FOLLOW: 0x1ad061,\n    YIELD: 0xff30f7,\n    OVERTAKE: 0x30a5ff,\n};\n\nexport const mainDecisionStopReasonMarkerMapping = {\n    STOP_REASON_HEAD_VEHICLE: reasonHeadVehicle,\n    STOP_REASON_DESTINATION: reasonDestination,\n    STOP_REASON_PEDESTRIAN: reasonPedestrian,\n    STOP_REASON_OBSTACLE: reasonObstacle,\n    STOP_REASON_SIGNAL: reasonSignal,\n    STOP_REASON_STOP_SIGN: reasonStopSign,\n    STOP_REASON_YIELD_SIGN: reasonYieldSign,\n    STOP_REASON_CLEAR_ZONE: reasonClearZone,\n    STOP_REASON_CROSSWALK: reasonCrosswalk,\n    STOP_REASON_EMERGENCY: reasonEmergency,\n    STOP_REASON_NOT_READY: reasonNotReady,\n    STOP_REASON_PULL_OVER: reasonPullover,\n};\n\nexport const mainDecisionChangeLaneMarkerMapping = {\n    LEFT: iconChangeLaneLeft,\n    RIGHT: iconChangeLaneRight,\n};\n\nexport const decisionFenceMapping = {\n    STOP: fenceObjectStop,\n    FOLLOW: fenceObjectFollow,\n    YIELD: fenceObjectYield,\n    OVERTAKE: fenceObjectOvertake,\n    MAIN_STOP: fenceMainStop,\n};\n\nexport const obstacleDecisionIconMapping = {\n    STOP: iconObjectStop,\n    FOLLOW: iconObjectFollow,\n    YIELD: iconObjectYield,\n    OVERTAKE: iconObjectOvertake,\n    MAIN_STOP: iconMainStop,\n};\n\nexport const cameraParams = {\n    Default: {\n        fov: 60,\n        near: 1,\n        far: 300,\n    },\n    Near: {\n        fov: 60,\n        near: 1,\n        far: 200,\n    },\n    Overhead: {\n        fov: 60,\n        near: 1,\n        far: 100,\n    },\n    Map: {\n        fov: 70,\n        near: 1,\n        far: 4000,\n    },\n};\n","import { lowerFirst } from 'lodash';\nimport * as THREE from 'three';\nimport { cameraParams } from '../constant/common';\n\nexport default class View {\n    private defaultViewDistance;\n\n    private nearViewDistance;\n\n    private overheadViewDistance;\n\n    private mapViewDistance;\n\n    private camera: THREE.PerspectiveCamera;\n\n    private viewAngle;\n\n    private controls;\n\n    public viewType = 'Default';\n\n    private adc;\n\n    public constructor(camera, controls, adc) {\n        this.defaultViewDistance = 22.5;\n        this.nearViewDistance = 11.25;\n        this.overheadViewDistance = 90;\n        this.mapViewDistance = 50;\n        this.camera = camera;\n        this.viewAngle = 0.8;\n        this.controls = controls;\n        this.adc = adc;\n    }\n\n    public setDefaultViewDistance(distance) {\n        this.defaultViewDistance = distance;\n    }\n\n    public setNearViewDistance(distance) {\n        this.nearViewDistance = distance;\n    }\n\n    public setOverheadViewDistance(distance) {\n        this.overheadViewDistance = distance;\n    }\n\n    public setMapViewDistance(distance) {\n        this.mapViewDistance = distance;\n    }\n\n    public setViewAngle(angle) {\n        this.viewAngle = angle;\n    }\n\n    public setViewType(type) {\n        this.viewType = type;\n    }\n\n    public setView() {\n        if (!this.adc) {\n            return;\n        }\n        const target = this.adc?.adc;\n        this.camera.fov = cameraParams[this.viewType].fov;\n        this.camera.near = cameraParams[this.viewType].near;\n        this.camera.far = cameraParams[this.viewType].far;\n        const { x = 0, y = 0, z = 0 } = target?.position || {};\n        const rotationY = target?.rotation.y || 0;\n        const offsetX =\n            this[`${lowerFirst(this.viewType)}ViewDistance`] * Math.cos(rotationY) * Math.cos(this.viewAngle);\n        const offsetY =\n            this[`${lowerFirst(this.viewType)}ViewDistance`] * Math.sin(rotationY) * Math.cos(this.viewAngle);\n        const offsetZ = this[`${lowerFirst(this.viewType)}ViewDistance`] * Math.sin(this.viewAngle);\n        switch (this.viewType) {\n            case 'Default':\n            case 'Near':\n                this.camera.position.set(x - offsetX, y - offsetY, z + offsetZ);\n                this.camera.up.set(0, 0, 1);\n                this.camera.lookAt(x + offsetX, y + offsetY, 0);\n                this.controls.enabled = false;\n                break;\n            case 'Overhead':\n                this.camera.position.set(x, y, z + offsetZ);\n                this.camera.up.set(0, 1, 0);\n                this.camera.lookAt(x, y + offsetY / 8, z);\n                this.controls.enabled = false;\n                break;\n            case 'Map':\n                if (!this.controls.enabled) {\n                    this.camera.position.set(x, y, z + this.mapViewDistance);\n                    this.camera.up.set(0, 0, 1);\n                    this.camera.lookAt(x, y, 0);\n                    this.controls.enabled = true;\n                    this.controls.target0 = new THREE.Vector3(x, y, 0);\n                    this.controls.position0 = this.camera.position.clone();\n                    this.controls.zoom0 = this.camera.zoom;\n                    this.controls.enabledRotate = true;\n                    this.controls.reset();\n                }\n                break;\n            default:\n                break;\n        }\n        this.camera.updateProjectionMatrix();\n    }\n\n    public updateViewDistance(offset) {\n        if (this.viewType === 'Map') {\n            this.controls.enabled = false;\n        }\n        const near = cameraParams[this.viewType].near;\n        const far = cameraParams[this.viewType].far;\n        const curDistance = this[`${lowerFirst(this.viewType)}ViewDistance`];\n        let newDistance = Math.min(far, curDistance + offset);\n        newDistance = Math.max(near, curDistance + offset);\n        this[`set${this.viewType}ViewDistance`](newDistance);\n        this.setView();\n    }\n\n    public changeViewType(type) {\n        this.setViewType(type);\n        this.setView();\n    }\n}\n","import * as THREE from 'three';\nimport { colorMapping, zOffset } from '../constant/common';\n\nexport function drawDashedLineFromPoints(points, lineAttr) {\n    const {\n        color = 0xff0000,\n        linewidth = 1,\n        dashSize = 4,\n        gapSize = 2,\n        zOffset = 0,\n        opacity = 1,\n        matrixAutoUpdate = true,\n    } = lineAttr;\n    const geometry = new THREE.BufferGeometry().setFromPoints(points);\n    const material = new THREE.LineDashedMaterial({\n        color,\n        dashSize,\n        linewidth,\n        gapSize,\n        transparent: true,\n        opacity,\n    });\n    const mesh = new THREE.Line(geometry, material);\n    mesh.computeLineDistances();\n    mesh.position.z = zOffset;\n    mesh.matrixAutoUpdate = matrixAutoUpdate;\n    if (!matrixAutoUpdate) {\n        mesh.updateMatrix();\n    }\n    return mesh;\n}\n\nexport function drawDashedLineFromPointsClone(points, material) {\n    const geometry = new THREE.BufferGeometry().setFromPoints(points);\n    const mesh = new THREE.Line(geometry, material);\n    mesh.computeLineDistances();\n    return mesh;\n}\n\nexport function drawSegmentsFromPointsClone(points, material) {\n    const geometry = new THREE.BufferGeometry().setFromPoints(points);\n    const mesh = new THREE.Line(geometry, material);\n    return mesh;\n}\n\nexport function drawSegmentsFromPoints(points, lineAttr) {\n    const { color = 0xff0000, linewidth = 1, zOffset = 0, opacity = 1, matrixAutoUpdate = true } = lineAttr;\n    const geometry = new THREE.BufferGeometry().setFromPoints(points);\n    const material = new THREE.LineBasicMaterial({\n        color,\n        linewidth,\n        transparent: true,\n        opacity,\n    });\n    const mesh = new THREE.Line(geometry, material);\n    mesh.position.z = zOffset;\n    mesh.matrixAutoUpdate = matrixAutoUpdate;\n    if (matrixAutoUpdate === false) {\n        mesh.updateMatrix();\n    }\n    return mesh;\n}\n\nexport function drawLaneMesh(laneType, points) {\n    let left = null;\n    let right = null;\n    switch (laneType) {\n        case 'DOTTED_YELLOW':\n            return drawDashedLineFromPoints(points, {\n                color: colorMapping.YELLOW,\n                linewidth: 4,\n                dashSize: 3,\n                gapSize: 3,\n                zOffset: zOffset.lane,\n                opacity: 1,\n                matrixAutoUpdate: false,\n            });\n        case 'DOTTED_WHITE':\n            return drawDashedLineFromPoints(points, {\n                color: colorMapping.WHITE,\n                linewidth: 2,\n                dashSize: 0.5,\n                gapSize: 0.25,\n                zOffset: zOffset.lane,\n                opacity: 0.4,\n                matrixAutoUpdate: false,\n            });\n        case 'SOLID_YELLOW':\n            return drawSegmentsFromPoints(points, {\n                color: colorMapping.YELLOW,\n                linewidth: 3,\n                zOffset: zOffset.lane,\n                opacity: 1,\n                matrixAutoUpdate: false,\n            });\n        case 'SOLID_WHITE':\n            return drawSegmentsFromPoints(points, {\n                color: colorMapping.WHITE,\n                linewidth: 3,\n                zOffset: zOffset.lane,\n                opacity: 1,\n                matrixAutoUpdate: false,\n            });\n        case 'DOUBLE_YELLOW':\n            left = drawSegmentsFromPoints(points, {\n                color: colorMapping.YELLOW,\n                linewidth: 2,\n                zOffset: zOffset.lane,\n                opacity: 1,\n                matrixAutoUpdate: false,\n            });\n            right = drawSegmentsFromPoints(\n                points.map((point) => new THREE.Vector3(point.x + 0.3, point.y + 0.3, point.z)),\n                {\n                    color: colorMapping.YELLOW,\n                    linewidth: 3,\n                    zOffset: zOffset.lane,\n                    opacity: 1,\n                    matrixAutoUpdate: false,\n                },\n            );\n            left.add(right);\n            return left;\n        case 'CURB':\n            return drawSegmentsFromPoints(points, {\n                color: colorMapping.CORAL,\n                linewidth: 3,\n                zOffset: zOffset.lane,\n                opacity: 1,\n                matrixAutoUpdate: false,\n            });\n        default:\n            return drawSegmentsFromPoints(points, {\n                color: colorMapping.DEFAULT,\n                linewidth: 3,\n                zOffset: zOffset.lane,\n                opacity: 1,\n                matrixAutoUpdate: false,\n            });\n    }\n}\n","import * as THREE from 'three';\nimport { MeshLine, MeshLineMaterial, MeshLineRaycast } from 'three.meshline';\nimport { drawSegmentsFromPoints } from './line';\n\nexport const coordinatesSame = (coord1, coord2): boolean =>\n    coord1.x === coord2.x && coord1.y === coord2.y && coord1.z === coord2.z;\n\nexport const getObjectBox3 = (object): THREE.Box3 => {\n    const box = new THREE.Box3();\n    box.expandByObject(object);\n    return box;\n};\nexport const getObjectLengthAndWidth = (object) => {\n    const box = new THREE.Box3();\n    box.expandByObject(object);\n    const length = box.max.x - box.min.x;\n    const width = box.max.y - box.min.y;\n    return [length, width];\n};\n\nexport const disposeMesh = (mesh) => {\n    mesh?.geometry?.dispose();\n    mesh?.material?.dispose();\n};\n\nexport const disposeGroup = (group) => {\n    group.traverse((child) => {\n        disposeMesh(child);\n    });\n};\n\nexport const drawCircle = (radius, material, segments = 32) => {\n    const geometry = new THREE.CircleGeometry(radius, segments);\n    const circleMesh = new THREE.Mesh(geometry, material);\n    return circleMesh;\n};\n\nexport const drawArrow = (color, length = 1.5, conelength = 0.5, conewidth = 0.5) => {\n    const end = new THREE.Vector3(length, 0, 0);\n    const begin = new THREE.Vector3(0, 0, 0);\n    const top = new THREE.Vector3(length - conewidth, conelength / 2, 0);\n    const bottom = new THREE.Vector3(length - conewidth, -conelength / 2, 0);\n    const points = [begin, end, top, end, bottom];\n    const arrow = drawSegmentsFromPoints(points, {\n        color,\n        linewidth: 1,\n        zOffset: 1,\n        opacity: 1,\n        matrixAutoUpdate: true,\n    });\n    return arrow;\n};\n\nexport const drawImge = (img, width, height) => {\n    const textLoader = new THREE.TextureLoader();\n    const material = new THREE.MeshBasicMaterial({\n        map: textLoader.load(img),\n        transparent: true,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n    });\n    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);\n    return mesh;\n};\n\nexport const addOutLineToObject = (object, color) => {\n    const ouline = new THREE.LineSegments(\n        new THREE.EdgesGeometry(object.geometry),\n        new THREE.LineBasicMaterial({\n            color,\n            shadowSide: THREE.DoubleSide,\n            depthTest: false,\n        }),\n    );\n    object.add(ouline);\n};\n\nexport const drawSolidBox = (x, y, z, color) => {\n    const geometry = new THREE.BoxGeometry(x, y, z);\n    const material = new THREE.MeshBasicMaterial({\n        color,\n        transparent: true,\n        opacity: 0.8,\n    });\n    const box = new THREE.Mesh(geometry, material);\n    addOutLineToObject(box, color);\n    return box;\n};\n\nexport const drawBox = (x, y, z, color) => {\n    const geometry = new THREE.BoxGeometry(x, y, z);\n    const material = new THREE.MeshBasicMaterial({ color });\n    const box = new THREE.BoxHelper(new THREE.Mesh(geometry, material));\n    box.material.color.set(color);\n    return box;\n};\n\nexport const drawDashedBox = (x, y, z, color) => {\n    const geometry = new THREE.BoxGeometry(x, y, z);\n    const edge = new THREE.EdgesGeometry(geometry);\n    const dashedLine = new THREE.LineSegments(\n        edge,\n        new THREE.LineDashedMaterial({\n            color,\n            dashSize: 0.1,\n            gapSize: 0.1,\n        }),\n    );\n    dashedLine.computeLineDistances();\n    return dashedLine;\n};\n\nexport const drawThickBandFromPoints = (points, thickAttr) => {\n    const { color = 0xffffff, opacity = 1, lineWidth = 0.5 } = thickAttr;\n    if (!points || points.length === 0) {\n        return null;\n    }\n    const geometry = new THREE.BufferGeometry().setFromPoints(points);\n    const line = new MeshLine();\n    line.setGeometry(geometry);\n    const material = new MeshLineMaterial({\n        color,\n        lineWidth,\n        opacity,\n    });\n    const mesh = new THREE.Mesh(line, material);\n    return mesh;\n};\n\nexport const drawShapeFromPoints = (points, color) => {\n    const shape = new THREE.Shape();\n    shape.setFromPoints(points);\n    const geometry = new THREE.ShapeGeometry(shape);\n    const material = new THREE.MeshBasicMaterial({\n        color,\n    });\n    const mesh = new THREE.Mesh(geometry, material);\n    return mesh;\n};\n\nexport const drawEllipseGeometry = (aRadius, bRadius) => {\n    const path = new THREE.Shape();\n    path.absellipse(0, 0, aRadius, bRadius, 0, Math.PI * 2, false, 0);\n    const geometry = new THREE.ShapeGeometry(path);\n    return geometry;\n};\n","import * as THREE from 'three';\nimport { without } from 'lodash';\nimport { drawSegmentsFromPointsClone, drawDashedLineFromPointsClone } from '../../utils/line';\nimport { colorMapping, zOffset } from '../../constant/common';\nimport { disposeGroup, disposeMesh } from '../../utils/common';\n\nexport default class Lane {\n    public laneGroupMap;\n\n    private laneIdMeshMap;\n\n    private scene;\n\n    private text;\n\n    private option;\n\n    private drawedLaneIds;\n\n    private currentLaneIds;\n\n    public xmin;\n\n    public xmax;\n\n    public ymin;\n\n    public ymax;\n\n    public width;\n\n    public height;\n\n    public center;\n\n    private coordinates;\n\n    private dottedYellowLineDashedMaterialTemplate;\n\n    private dottedWhiteLineDashedMaterialTemplate;\n\n    private solidYellowLineBasicMaterialTemplate;\n\n    private solidWhiteLineBasicMaterialTemplate;\n\n    private curbLineBasicMaterialTemplate;\n\n    private defaultLineBasicMaterialTemplate;\n\n    private centerLineBasicMaterialTemplate;\n\n    DOTTED_YELLOW;\n\n    constructor(scene, text, option, coordinates) {\n        this.scene = scene;\n        this.option = option;\n        this.coordinates = coordinates;\n        this.laneGroupMap = {};\n        this.laneIdMeshMap = {};\n        this.text = text;\n        this.drawedLaneIds = [];\n        this.currentLaneIds = [];\n        this.width = 0;\n        this.height = 0;\n        this.xmax = -Infinity;\n        this.xmin = Infinity;\n        this.ymin = Infinity;\n        this.ymax = -Infinity;\n        this.center = new THREE.Vector3(0, 0, 0);\n        this.dottedYellowLineDashedMaterialTemplate = new THREE.LineDashedMaterial({\n            color: colorMapping.YELLOW,\n            dashSize: 3,\n            gapSize: 3,\n            transparent: true,\n            opacity: 1,\n        });\n        this.dottedWhiteLineDashedMaterialTemplate = new THREE.LineDashedMaterial({\n            color: colorMapping.WHITE,\n            dashSize: 0.5,\n            gapSize: 0.25,\n            transparent: true,\n            opacity: 0.4,\n        });\n        this.solidYellowLineBasicMaterialTemplate = new THREE.LineBasicMaterial({\n            color: colorMapping.YELLOW,\n            transparent: true,\n            opacity: 1,\n        });\n        this.solidWhiteLineBasicMaterialTemplate = new THREE.LineBasicMaterial({\n            color: colorMapping.WHITE,\n            opacity: 1,\n            transparent: true,\n        });\n        this.curbLineBasicMaterialTemplate = new THREE.LineBasicMaterial({\n            color: colorMapping.CORAL,\n            opacity: 1,\n            transparent: true,\n        });\n        this.centerLineBasicMaterialTemplate = new THREE.LineBasicMaterial({\n            color: colorMapping.GREEN,\n            opacity: 1,\n            transparent: true,\n        });\n    }\n\n    drawLaneMesh(laneType, points) {\n        let left = null;\n        let right = null;\n        switch (laneType) {\n            case 'DOTTED_YELLOW':\n                return drawDashedLineFromPointsClone(points, this.dottedYellowLineDashedMaterialTemplate);\n            case 'DOTTED_WHITE':\n                return drawDashedLineFromPointsClone(points, this.dottedWhiteLineDashedMaterialTemplate);\n            case 'SOLID_YELLOW':\n                return drawSegmentsFromPointsClone(points, this.solidYellowLineBasicMaterialTemplate);\n            case 'SOLID_WHITE':\n                return drawSegmentsFromPointsClone(points, this.solidWhiteLineBasicMaterialTemplate);\n            case 'DOUBLE_YELLOW':\n                left = drawSegmentsFromPointsClone(points, this.solidYellowLineBasicMaterialTemplate);\n                right = drawSegmentsFromPointsClone(points, this.solidYellowLineBasicMaterialTemplate);\n                left.add(right);\n                return left;\n            case 'CURB':\n                return drawSegmentsFromPointsClone(points, this.curbLineBasicMaterialTemplate);\n            default:\n                return drawSegmentsFromPointsClone(points, this.defaultLineBasicMaterialTemplate);\n        }\n    }\n\n    drawLanes(lanes) {\n        if (!this.option.layerOption.Map.laneId) {\n            this.disposeLaneIds();\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        this.currentLaneIds = [];\n        lanes.forEach((lane) => {\n            const id = lane.id.id;\n            this.currentLaneIds.push(id);\n            // \n            if (this.option.layerOption.Map.laneId && !this.laneIdMeshMap[id]) {\n                this.drawLaneId(lane);\n            }\n            if (this.laneGroupMap[id]) {\n                return;\n            }\n            const group = new THREE.Group();\n            group.name = id;\n            const centralLine = lane.centralCurve.segment;\n            centralLine.forEach((segment) => {\n                const points = this.coordinates.applyOffsetToArray(segment.lineSegment.point);\n                points.forEach((p) => {\n                    this.xmin = Math.min(p.x, this.xmin);\n                    this.xmax = Math.max(p.x, this.xmax);\n                    this.ymin = Math.min(p.y, this.ymin);\n                    this.ymax = Math.max(p.y, this.ymax);\n                });\n                const centerLine = drawSegmentsFromPointsClone(points, this.centerLineBasicMaterialTemplate);\n                centerLine.name = `CentralLine-${id}`;\n                this.scene.add(centerLine);\n            });\n            const rightLaneType = lane.rightBoundary.boundaryType[0].types[0];\n            lane.rightBoundary.curve.segment.forEach((segment) => {\n                const points = this.coordinates.applyOffsetToArray(segment.lineSegment.point);\n                const boundary = this.drawLaneMesh(rightLaneType, points);\n                boundary.name = `RightBoundary-${id}`;\n                boundary.position.z = zOffset.lane;\n                group.add(boundary);\n                this.scene.add(boundary);\n            });\n\n            const leftLaneType = lane.leftBoundary.boundaryType[0].types[0];\n            lane.leftBoundary.curve.segment.forEach((segment) => {\n                const points = this.coordinates.applyOffsetToArray(segment.lineSegment.point);\n                const boundary = this.drawLaneMesh(leftLaneType, points);\n                boundary.name = `LeftBoundary-${id}`;\n                boundary.position.z = zOffset.lane;\n                group.add(boundary);\n                this.scene.add(boundary);\n            });\n            this.laneGroupMap[id] = group;\n            this.drawedLaneIds.push(id);\n        });\n        this.width = this.xmax - this.xmin;\n        this.height = this.ymax - this.ymin;\n        this.center = new THREE.Vector3((this.xmax + this.xmin) / 2, (this.ymax + this.ymin) / 2, 0);\n        this.removeOldLanes();\n    }\n\n    drawLaneId(lane) {\n        const id = lane.id.id;\n        if (this.laneIdMeshMap[id]) {\n            return;\n        }\n\n        const centerLine = lane.centralCurve.segment;\n        const position = this.coordinates.applyOffset(centerLine?.[0]?.startPosition);\n        if (position) {\n            position.z = 0.04;\n        }\n\n        const points = centerLine?.[0].lineSegment?.point;\n        let rotationZ = 0;\n        if (points && points.length >= 2) {\n            const p1 = points[0];\n            const p2 = points[1];\n            rotationZ = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n        }\n\n        const textMesh = this.text.drawText(id, colorMapping.WHITE, position);\n        if (textMesh) {\n            textMesh.rotation.z = rotationZ;\n            this.laneIdMeshMap[id] = textMesh;\n            this.scene.add(textMesh);\n        }\n    }\n\n    dispose() {\n        this.xmax = -Infinity;\n        this.xmin = Infinity;\n        this.ymax = -Infinity;\n        this.ymin = Infinity;\n        this.width = 0;\n        this.height = 0;\n        this.center = new THREE.Vector3(0, 0, 0);\n        this.disposeLaneIds();\n        this.disposeLanes();\n    }\n\n    disposeLanes() {\n        this.drawedLaneIds = [];\n        this.currentLaneIds = [];\n        Object.keys(this.laneGroupMap).forEach((id) => {\n            const group = this.laneGroupMap[id];\n            disposeGroup(group);\n            this.scene.remove(group);\n        });\n        this.laneGroupMap = {};\n    }\n\n    disposeLaneIds() {\n        this.drawedLaneIds = [];\n        this.currentLaneIds = [];\n        this.text?.reset();\n        Object.keys(this.laneIdMeshMap).forEach((id) => {\n            const text = this.laneIdMeshMap[id];\n            this.scene.remove(text);\n        });\n        this.laneIdMeshMap = {};\n    }\n\n    removeOldLanes() {\n        const needRemovedLaneIds = without(this.drawedLaneIds, ...this.currentLaneIds);\n        if (needRemovedLaneIds && needRemovedLaneIds.length) {\n            needRemovedLaneIds.forEach((id) => {\n                const removedGroup = this.laneGroupMap[id];\n                disposeGroup(removedGroup);\n                this.scene.remove(removedGroup);\n                delete this.laneGroupMap[id];\n                this.drawedLaneIds = [...this.currentLaneIds];\n\n                const textMesh = this.laneIdMeshMap[id];\n\n                if (textMesh) {\n                    disposeMesh(textMesh);\n                    this.scene.remove(textMesh);\n                    delete this.laneIdMeshMap[id];\n                }\n            });\n        }\n    }\n}\n","import { coordinatesSame } from './common';\nimport { colorMapping } from '../constant/common';\nimport { drawSegmentsFromPoints } from './line';\n\nexport const drawPolygon = (points, polygonAttr) => {\n    const {\n        color = colorMapping.WHITE,\n        linewidth = 1,\n        zOffset = 0,\n        opacity = 1,\n        matrixAutoUpdate = true,\n    } = polygonAttr;\n    if (points.length < 3) {\n        throw new Error('there are less than 3 points, the polygon cannot be drawn');\n    }\n    const length = points.length;\n    if (!coordinatesSame(points[0], points[length - 1])) {\n        points.push(points[0]);\n    }\n    return drawSegmentsFromPoints(points, {\n        color,\n        linewidth,\n        zOffset,\n        opacity,\n        matrixAutoUpdate,\n    });\n};\n","import { without } from 'lodash';\nimport { drawPolygon } from '../../utils/polygon';\nimport { colorMapping, zOffset } from '../../constant/common';\nimport { disposeMesh } from '../../utils/common';\n\nexport default class Junction {\n    private meshs;\n\n    private scene;\n\n    private currentJunctionIds;\n\n    private coordinates;\n\n    constructor(scene, coordinates) {\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.meshs = {};\n        this.currentJunctionIds = [];\n    }\n\n    drawJunctions(junctions) {\n        this.currentJunctionIds = [];\n        if (!junctions || junctions.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        junctions.forEach((junction) => {\n            const id = junction.id.id;\n            this.currentJunctionIds.push(id);\n            if (this.meshs[id]) {\n                return;\n            }\n            const points = this.coordinates.applyOffsetToArray(junction.polygon.point);\n            const junctionMesh = drawPolygon(points, {\n                color: colorMapping.BLUE,\n                linewidth: 1,\n                zOffset: zOffset.junction,\n                opacity: 1,\n                matrixAutoUpdate: true,\n            });\n            junctionMesh.name = `junction${id}`;\n            this.meshs[id] = junctionMesh;\n            this.scene.add(junctionMesh);\n        });\n        this.removeOldJunctions();\n    }\n\n    dispose() {\n        Object.values(this.meshs).forEach((mesh) => {\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n        this.meshs = {};\n        this.currentJunctionIds = [];\n    }\n\n    removeOldJunctions() {\n        const needRemovedIds = without(Object.keys(this.meshs), ...this.currentJunctionIds);\n        if (needRemovedIds && needRemovedIds.length) {\n            needRemovedIds.forEach((id) => {\n                const mesh = this.meshs[id];\n                disposeMesh(mesh);\n                this.scene.remove(mesh);\n                delete this.meshs[id];\n            });\n        }\n    }\n}\n","import * as THREE from 'three';\nimport { disposeMesh } from '../../utils/common';\n\nexport default class Grid {\n    private mesh;\n\n    private scene;\n\n    private size;\n\n    constructor(scene) {\n        this.mesh = null;\n        this.scene = scene;\n        this.size = 0;\n    }\n\n    drawGrid(gidAttr, position) {\n        const { size, divisions, colorCenterLine = 0x000000, colorGrid = 0x000000 } = gidAttr;\n        if (size === this.size && this.mesh) {\n            this.mesh.position.set(position.x, position.y, 0);\n            return;\n        }\n        this.size = size;\n        this.dispose();\n        const gridHelper = new THREE.GridHelper(size, divisions, colorCenterLine, colorGrid);\n        gridHelper.rotateX(Math.PI / 2);\n        gridHelper.name = 'gridHelper';\n        (gridHelper.material as THREE.LineBasicMaterial).opacity = 0.3;\n        (gridHelper.material as THREE.LineBasicMaterial).transparent = true;\n        gridHelper.position.set(position.x, position.y, 0);\n        this.scene.add(gridHelper);\n        this.mesh = gridHelper;\n    }\n\n    dispose() {\n        disposeMesh(this.mesh);\n        this.scene.remove(this.mesh);\n        this.mesh = null;\n    }\n}\n","import * as THREE from 'three';\nimport { coordinatesSame } from './common';\nimport { colorMapping } from '../constant/common';\n\nexport const drawZone = (points, zoneAttr) => {\n    if (points.length < 3) {\n        throw new Error('there are less than 3 points, the zone cannot be drawn');\n    }\n\n    const { color = colorMapping.WHITE, zOffset = 0, opacity = 1, matrixAutoUpdate = true } = zoneAttr;\n\n    const length = points.length;\n    if (!coordinatesSame(points[0], points[length - 1])) {\n        points.push(points[0]);\n    }\n\n    const shape = new THREE.Shape(points);\n    const geometry = new THREE.ShapeGeometry(shape);\n    const material = new THREE.MeshBasicMaterial({\n        color,\n        opacity,\n        transparent: true,\n    });\n    const zoneMesh = new THREE.Mesh(geometry, material);\n    zoneMesh.position.z = zOffset;\n\n    if (!matrixAutoUpdate) {\n        zoneMesh.updateMatrix();\n    }\n    return zoneMesh;\n};\n","import * as THREE from 'three';\nimport { without } from 'lodash';\nimport { drawZone } from '../../utils/zone';\nimport { drawPolygon } from '../../utils/polygon';\nimport { colorMapping, zOffset } from '../../constant/common';\nimport { disposeGroup } from '../../utils/common';\n\nexport default class ClearArea {\n    private groups;\n\n    private scene;\n\n    private currentIds;\n\n    private coordinates;\n\n    constructor(scene, coordinates) {\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.groups = {};\n        this.currentIds = [];\n    }\n\n    drawClearAreas(clearAreas) {\n        this.currentIds = [];\n        if (!clearAreas || clearAreas.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        clearAreas.forEach((clearArea) => {\n            const id = clearArea.id.id;\n            this.currentIds.push(id);\n            if (this.groups[id]) {\n                return;\n            }\n            const group = new THREE.Group();\n            const points = this.coordinates.applyOffsetToArray(clearArea.polygon.point);\n            const zoneMesh = drawZone(points, {\n                color: colorMapping.YELLOW,\n                zOffset: zOffset.clearArea,\n                opacity: 0.3,\n                matrixAutoUpdate: true,\n            });\n            const lineMesh = drawPolygon(points, {\n                color: colorMapping.YELLOW,\n                linewidth: 1,\n                zOffset: zOffset.clearArea,\n                opacity: 1,\n                matrixAutoUpdate: true,\n            });\n            group.add(zoneMesh);\n            group.add(lineMesh);\n            this.groups[id] = group;\n            this.scene.add(group);\n        });\n        this.removeOldGroups();\n    }\n\n    dispose() {\n        Object.values(this.groups).forEach((group) => {\n            disposeGroup(group);\n            this.scene.remove(group);\n        });\n        this.groups = [];\n        this.currentIds = [];\n    }\n\n    removeOldGroups() {\n        const needRemovedIds = without(Object.keys(this.groups), ...this.currentIds);\n        if (needRemovedIds && needRemovedIds.length) {\n            needRemovedIds.forEach((id) => {\n                const removedGroup = this.groups[id];\n                disposeGroup(removedGroup);\n                this.scene.remove(removedGroup);\n                delete this.groups[id];\n            });\n        }\n    }\n}\n","import * as THREE from 'three';\nimport { without } from 'lodash';\nimport { drawZone } from '../../utils/zone';\nimport { drawPolygon } from '../../utils/polygon';\nimport { colorMapping, zOffset } from '../../constant/common';\nimport { disposeGroup } from '../../utils/common';\n\nexport default class ClearArea {\n    private groups;\n\n    private scene;\n\n    private currentIds;\n\n    private coordinates;\n\n    constructor(scene, coordinates) {\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.groups = {};\n        this.currentIds = [];\n    }\n\n    drawCrosswalk(crosswalks) {\n        this.currentIds = [];\n        if (!crosswalks || crosswalks.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        crosswalks.forEach((crosswalk) => {\n            const id = crosswalk.id.id;\n            this.currentIds.push(id);\n            if (this.groups[id]) {\n                return;\n            }\n            const group = new THREE.Group();\n            const points = this.coordinates.applyOffsetToArray(crosswalk.polygon.point);\n            const zoneMesh = drawZone(points, {\n                color: colorMapping.PURE_WHITE,\n                zOffset: zOffset.clearArea,\n                opacity: 0.3,\n                matrixAutoUpdate: true,\n            });\n            const lineMesh = drawPolygon(points, {\n                color: colorMapping.YELLOW,\n                linewidth: 1,\n                zOffset: zOffset.clearArea,\n                opacity: 1,\n                matrixAutoUpdate: true,\n            });\n            group.add(zoneMesh);\n            group.add(lineMesh);\n            this.groups[id] = group;\n            this.scene.add(group);\n        });\n        this.removeOldGroups();\n    }\n\n    dispose() {\n        Object.values(this.groups).forEach((group) => {\n            disposeGroup(group);\n            this.scene.remove(group);\n        });\n        this.groups = [];\n        this.currentIds = [];\n    }\n\n    removeOldGroups() {\n        const needRemovedIds = without(Object.keys(this.groups), ...this.currentIds);\n        if (needRemovedIds && needRemovedIds.length) {\n            needRemovedIds.forEach((id) => {\n                const removedGroup = this.groups[id];\n                disposeGroup(removedGroup);\n                this.scene.remove(removedGroup);\n                delete this.groups[id];\n            });\n        }\n    }\n}\n","import * as THREE from 'three';\nimport { without } from 'lodash';\nimport { drawZone } from '../../utils/zone';\nimport { drawPolygon } from '../../utils/polygon';\nimport { colorMapping, zOffset } from '../../constant/common';\nimport { disposeGroup } from '../../utils/common';\n\nexport default class PncJunction {\n    private groups;\n\n    private scene;\n\n    private currentIds;\n\n    private coordinates;\n\n    constructor(scene, coordinates) {\n        this.groups = {};\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.currentIds = [];\n    }\n\n    drawPncJunctions(pncJunctions) {\n        this.currentIds = [];\n        if (!pncJunctions || pncJunctions.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        pncJunctions.forEach((pncJunction) => {\n            const id = pncJunction.id.id;\n            this.currentIds.push(id);\n            if (this.groups[id]) {\n                return;\n            }\n            const pncJunctionGroup = new THREE.Group();\n            const points = this.coordinates.applyOffsetToArray(pncJunction.polygon.point);\n            const zoneMesh = drawZone(points, {\n                color: colorMapping.BLUE,\n                zOffset: zOffset.pncJunction,\n                opacity: 0.3,\n                matrixAutoUpdate: true,\n            });\n\n            const lineMesh = drawPolygon(points, {\n                color: colorMapping.BLUE,\n                linewidth: 1,\n                zOffset: zOffset.pncJunction,\n                opacity: 1,\n                matrixAutoUpdate: true,\n            });\n\n            pncJunctionGroup.add(zoneMesh);\n            pncJunctionGroup.add(lineMesh);\n\n            this.groups[id] = pncJunctionGroup;\n            this.scene.add(pncJunctionGroup);\n        });\n        this.removeOldGroups();\n    }\n\n    dispose() {\n        Object.values(this.groups).forEach((group) => {\n            disposeGroup(group);\n            this.scene.remove(group);\n        });\n        this.groups = [];\n        this.currentIds = [];\n    }\n\n    removeOldGroups() {\n        const needRemovedIds = without(Object.keys(this.groups), ...this.currentIds);\n        if (needRemovedIds && needRemovedIds.length) {\n            needRemovedIds.forEach((id) => {\n                const removedGroup = this.groups[id];\n                disposeGroup(removedGroup);\n                this.scene.remove(removedGroup);\n                delete this.groups[id];\n            });\n        }\n    }\n}\n","import * as THREE from 'three';\nimport { without } from 'lodash';\nimport { drawLaneMesh } from '../../utils/line';\nimport { disposeGroup } from '../../utils/common';\n\nexport default class Road {\n    private roadMap;\n\n    private scene;\n\n    private currentRoadIds;\n\n    private coordinates;\n\n    constructor(scene, coordinates) {\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.roadMap = {};\n        this.currentRoadIds = [];\n    }\n\n    drawRoads(roads) {\n        this.currentRoadIds = [];\n        if (!roads || roads.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        roads.forEach((road) => {\n            const id = road.id.id;\n            this.currentRoadIds.push(id);\n            if (this.roadMap[id]) {\n                return;\n            }\n            const group = new THREE.Group();\n            road.section.forEach((section) => {\n                section.boundary.outerPolygon.edge.forEach((edge) => {\n                    edge.curve.segment.forEach((segment) => {\n                        const points = this.coordinates.applyOffsetToArray(segment.lineSegment.point);\n                        const boundary = drawLaneMesh('CURB', points);\n                        group.add(boundary);\n                    });\n                });\n            });\n            group.name = `Road-${id}`;\n            this.roadMap[id] = group;\n            this.scene.add(group);\n        });\n        this.removeOldLanes();\n    }\n\n    dispose() {\n        Object.values(this.roadMap).forEach((item) => {\n            disposeGroup(item);\n            this.scene.remove(item);\n        });\n        this.roadMap = {};\n        this.currentRoadIds = [];\n    }\n\n    removeOldLanes() {\n        const needRemovedRoadIds = without(Object.keys(this.roadMap), ...this.currentRoadIds);\n        // console.log(needRemovedRoadIds, '###');\n        if (needRemovedRoadIds && needRemovedRoadIds.length) {\n            needRemovedRoadIds.forEach((id) => {\n                const removedGroup = this.roadMap[id];\n                disposeGroup(removedGroup);\n                this.scene.remove(removedGroup);\n                delete this.roadMap[id];\n            });\n        }\n    }\n}\n","export default __webpack_public_path__ + \"1ccfd159b578eca9334d70b48d2b0344.mtl\";","export default __webpack_public_path__ + \"37989bff61e1e138fc178da4c7962278.obj\";","import { drawSegmentsFromPoints } from './line';\nimport { colorMapping, zOffset } from '../constant/common';\n\nexport const drawStopLine = (stopLine, coordinates) => {\n    if (!stopLine) {\n        return [];\n    }\n    const meshs = [];\n    stopLine.segment?.forEach((segment) => {\n        const points = coordinates.applyOffsetToArray(segment.lineSegment.point);\n        const mesh = drawSegmentsFromPoints(points, {\n            color: colorMapping.PURE_WHITE,\n            linewidth: 5,\n            zOffset: zOffset.stopLine,\n            opacity: 1,\n        });\n        meshs.push(mesh);\n    });\n    return meshs;\n};\n","import * as THREE from 'three';\nimport { meanBy } from 'lodash';\n\nconst EPSILON = 1e-9;\n\nexport const getHeadingFromStopLine = (stopLine) => {\n    if (!stopLine) {\n        return NaN;\n    }\n    const points = stopLine.segment[0]?.lineSegment?.point;\n    if (points && points.length >= 2) {\n        const length = points.length;\n        const stopLineDirection = Math.atan2(points[length - 1].y - points[0].y, points[length - 1].x - points[0].x);\n        return Math.PI * 1.5 + stopLineDirection;\n    }\n    return NaN;\n};\nexport const getHeadingFromStopLineAndTrafficLightBoundary = (signal) => {\n    const boundaryPoints = signal.boundary.point;\n    if (boundaryPoints.length < 3) {\n        console.warn(`cannot get three points from boundary,signal_id:${signal.id.id}`);\n        if (signal.stopLine[0]) {\n            return getHeadingFromStopLine(signal.stopLine[0]);\n        }\n        return NaN;\n    }\n    const boundary1 = boundaryPoints[0];\n    const boundary2 = boundaryPoints[1];\n    const boundary3 = boundaryPoints[2];\n    const orthogonalX =\n        (boundary2.x - boundary1.x) * (boundary3.z - boundary1.z) -\n        (boundary3.x - boundary1.x) * (boundary2.z - boundary1.z);\n    const orthogonalY =\n        (boundary2.y - boundary1.y) * (boundary3.z - boundary1.z) -\n        (boundary3.y - boundary1.y) * (boundary2.z - boundary1.z);\n    const orthogonalConstant = -orthogonalX * boundary1.x - orthogonalY * boundary1.y;\n\n    const stopLinePoints = signal.stopLine[0]?.segment[0]?.lineSegment?.point;\n    const len = stopLinePoints.length;\n    if (len < 2) {\n        console.warn(`Cannot get any stop line, signal_id: ${signal.id.id}`);\n        return NaN;\n    }\n    // construct ax+by+c=0 ==> stopLineX*x+stopLineY*y+constant=0\n    const stopLineX = stopLinePoints[len - 1].y - stopLinePoints[0].y;\n    const stopLineY = stopLinePoints[0].x - stopLinePoints[len - 1].x;\n    const stopLineConstant = -stopLineX * stopLinePoints[0].x - stopLineY * stopLinePoints[0].y;\n\n    // calculate the intersection\n    if (Math.abs(stopLineX * orthogonalY - orthogonalX * stopLineY) < EPSILON) {\n        console.warn('The signal orthogonal direction is parallel to the stop line,', `signal_id: ${signal.id.id}`);\n        return getHeadingFromStopLine(signal.stopLine[0]);\n    }\n    const intersectX =\n        (stopLineY * orthogonalConstant - orthogonalY * stopLineConstant) /\n        (stopLineX * orthogonalY - orthogonalX * stopLineY);\n    const intersectY =\n        stopLineY !== 0\n            ? (-stopLineX * intersectX - stopLineConstant) / stopLineY\n            : (-orthogonalX * intersectX - orthogonalConstant) / orthogonalY;\n    let direction = Math.atan2(-orthogonalX, orthogonalY);\n\n    // if the direction is not towards to intersection point, turn around\n    if ((direction < 0 && intersectY > boundary1.y) || (direction > 0 && intersectY < boundary1.y)) {\n        direction += Math.PI;\n    }\n    return direction;\n};\n\nexport const getPositionAndHeading = (signal) => {\n    const locations = [];\n    if (signal.position && signal.heading) {\n        return {\n            position: signal.position,\n            heading: signal.heading,\n        };\n    }\n    if (!signal.subsignal || signal.subsignal.length === 0) {\n        return {};\n    }\n\n    signal.subsignal.forEach((subsignal) => {\n        if (subsignal.location) {\n            locations.push(subsignal.location);\n        }\n    });\n\n    if (locations.length === 0) {\n        if (signal.boundary?.point?.length) {\n            console.warn('subsignal locations not found,use signal bounday instead.');\n            locations.push(signal.boundary.point);\n        } else {\n            console.warn('unable to determine signal location,skip.');\n            return {};\n        }\n    }\n\n    const heading = getHeadingFromStopLineAndTrafficLightBoundary(signal);\n    if (!Number.isNaN(heading)) {\n        const position = new THREE.Vector3(0, 0, 0);\n        position.x = meanBy(locations, (l) => l.x);\n        position.y = meanBy(locations, (l) => l.y);\n        return { position, heading };\n    }\n    return {};\n};\n","import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';\nimport * as THREE from 'three';\nimport { without } from 'lodash';\nimport yieldSignMaterial from '../../../assets/models/yield_sign.mtl';\nimport yieldSignObj from '../../../assets/models/yield_sign.obj';\nimport { drawStopLine } from '../../utils/stopLine';\nimport { disposeMesh } from '../../utils/common';\nimport { getHeadingFromStopLine } from '../../utils/signal';\n\nconst STOP_SIGN_SCALE = 0.01;\nexport default class YieldSignal {\n    private yieldSignTemplate;\n\n    private scene;\n\n    private yieldLineMeshs;\n\n    private yieldSignMeshs;\n\n    private currentYieldgnalIds;\n\n    private coordinates;\n\n    constructor(scene, coordinates) {\n        this.yieldSignTemplate = null;\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.yieldLineMeshs = {};\n        this.yieldSignMeshs = {};\n        this.currentYieldgnalIds = [];\n        this.iniYieldSignTemplate();\n    }\n\n    getPositionAndHeading(yieldSign) {\n        if (!yieldSign?.stopLine?.[0]) {\n            return {};\n        }\n        const heading = getHeadingFromStopLine(yieldSign.stopLine[0]);\n\n        if (!Number.isNaN(heading)) {\n            const points = this.coordinates.applyOffsetToArray(yieldSign.stopLine?.[0].segment?.[0].lineSegment?.point);\n            const length = points.length;\n            const stopLinePoint = points[length - 1];\n            let position = new THREE.Vector3(stopLinePoint.x, stopLinePoint.y, 0);\n            position = this.coordinates.applyOffset(position);\n            return { position, heading };\n        }\n        return {};\n    }\n\n    iniYieldSignTemplate() {\n        const mtlLoader = new MTLLoader();\n        const objLoader = new OBJLoader();\n        mtlLoader.load(yieldSignMaterial, (material) => {\n            material.preload();\n            objLoader.setMaterials(material);\n            objLoader.load(yieldSignObj, (object) => {\n                object.rotateX(Math.PI / 2);\n                this.yieldSignTemplate = object;\n            });\n        });\n    }\n\n    drawYieldSigns(yieldSigns) {\n        this.currentYieldgnalIds = [];\n        if (!this.yieldSignTemplate) {\n            return;\n        }\n        if (!yieldSigns || yieldSigns.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        yieldSigns.forEach((yieldSign) => {\n            const id = yieldSign.id.id;\n            this.currentYieldgnalIds.push(id);\n            if (this.yieldSignMeshs[id]) {\n                return;\n            }\n            const mesh = this.yieldSignTemplate.clone();\n            const { position, heading } = this.getPositionAndHeading(yieldSign);\n            if (!position) {\n                return;\n            }\n\n            mesh.rotation.y = heading || 0;\n            mesh.position.set(position.x, position.y, 0);\n            mesh.scale.set(STOP_SIGN_SCALE, STOP_SIGN_SCALE, STOP_SIGN_SCALE);\n            this.yieldSignMeshs[id] = mesh;\n            this.scene.add(mesh);\n\n            const stopLine = yieldSign.stopLine;\n            if (stopLine) {\n                stopLine.forEach((item) => {\n                    const meshs = drawStopLine(item, this.coordinates);\n                    meshs.forEach((mesh) => {\n                        this.yieldLineMeshs[id] = this.yieldLineMeshs[id] || [];\n                        this.yieldLineMeshs[id].push(mesh);\n                        this.scene.add(mesh);\n                    });\n                });\n            }\n        });\n        this.removeOldTrafficSignals();\n    }\n\n    dispose() {\n        Object.values(this.yieldSignMeshs).forEach((mesh) => {\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n\n        Object.keys(this.yieldLineMeshs).forEach((id) => {\n            const meshArr = this.yieldLineMeshs[id];\n            meshArr.forEach((item) => {\n                disposeMesh(item);\n                this.scene.remove(item);\n            });\n        });\n        this.yieldLineMeshs = {};\n        this.yieldSignMeshs = {};\n        this.currentYieldgnalIds = [];\n    }\n\n    removeOldTrafficSignals() {\n        const drawedStopSignalIds = Object.keys(this.yieldSignMeshs);\n        const needRemovedStopSignals = without(drawedStopSignalIds, ...this.currentYieldgnalIds);\n        if (needRemovedStopSignals && needRemovedStopSignals.length) {\n            needRemovedStopSignals.forEach((id) => {\n                const removedSignal = this.yieldSignMeshs[id];\n                disposeMesh(removedSignal);\n                this.scene.remove(removedSignal);\n                delete this.yieldSignMeshs[id];\n\n                const stopLineMeshs = this.yieldLineMeshs[id];\n                stopLineMeshs.forEach((item) => {\n                    disposeMesh(item);\n                    this.scene.remove(item);\n                });\n                delete this.yieldLineMeshs[id];\n            });\n        }\n    }\n}\n","export default __webpack_public_path__ + \"f015f868c7133c9513a49d2e92dbca47.mtl\";","export default __webpack_public_path__ + \"68ec784dbe4a4a6eb772b375b8c1a222.obj\";","import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';\nimport { without } from 'lodash';\nimport { Mesh } from 'three';\nimport { drawStopLine } from '../../utils/stopLine';\nimport trafficLightMaterial from '../../../assets/models/traffic_light.mtl';\nimport trafficLightObject from '../../../assets/models/traffic_light.obj';\nimport { disposeMesh } from '../../utils/common';\nimport { getPositionAndHeading } from '../../utils/signal';\n\nconst TRAFFIC_LIGHT_SCALE = 2.3;\nconst SUBSIGNAL_TO_INDEX = {\n    GREEN: 6,\n    YELLOW: 5,\n    RED: 4,\n};\nconst SUBSIGNAL_TO_LIGHT = {\n    GREEN: 0x14f470,\n    YELLOW: 0xcec832,\n    RED: 0xff0000,\n};\n\nexport default class TrafficSignal {\n    private trafficMaterials;\n\n    private stopLineMeshs;\n\n    private trafficBaseMeshTemplate;\n\n    private baseSignalMeshs;\n\n    private signalStatusMeshs;\n\n    private scene;\n\n    private currentTrafficSignalIds;\n\n    private coordinates;\n\n    constructor(scene, coordinates) {\n        this.trafficBaseMeshTemplate = null;\n        this.trafficMaterials = {};\n        this.baseSignalMeshs = {};\n        this.signalStatusMeshs = [];\n        this.currentTrafficSignalIds = [];\n        this.stopLineMeshs = {};\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.initTrafficTemplate();\n    }\n\n    initTrafficTemplate() {\n        const mtlLoader = new MTLLoader();\n        const objLoader = new OBJLoader();\n        const getLightMaterial = (originMaterial, subsignal) => {\n            const lightMaterial = originMaterial.clone();\n            lightMaterial.emissive.set(SUBSIGNAL_TO_LIGHT[subsignal]);\n            return lightMaterial;\n        };\n\n        mtlLoader.load(trafficLightMaterial, async (materials) => {\n            const [, , DARK_GREEN, DARK_YELLOW, DARK_RED] = materials.getAsArray();\n            this.trafficMaterials = {\n                GREEN: {\n                    DARK: DARK_GREEN,\n                    LIGHT: getLightMaterial(DARK_GREEN, 'GREEN'),\n                },\n                YELLOW: {\n                    DARK: DARK_YELLOW,\n                    LIGHT: getLightMaterial(DARK_YELLOW, 'YELLOW'),\n                },\n                RED: {\n                    DARK: DARK_RED,\n                    LIGHT: getLightMaterial(DARK_RED, 'RED'),\n                },\n            };\n\n            materials.preload();\n            objLoader.setMaterials(materials);\n            objLoader.load(trafficLightObject, (object) => {\n                object.rotation.x = Math.PI / 2;\n                this.trafficBaseMeshTemplate = object;\n            });\n        });\n    }\n\n    updateTrafficStatus(signals) {\n        if (signals && signals.length !== 0) {\n            this.clearSignalStatus();\n            const trafficSignalCurMapping = {};\n            signals.forEach((signal) => {\n                trafficSignalCurMapping[signal.id.id] = signal.currentSignal;\n            });\n\n            Object.keys(this.baseSignalMeshs).forEach((id) => {\n                if (id in trafficSignalCurMapping) {\n                    const mesh = this.baseSignalMeshs[id];\n                    const subsignal = trafficSignalCurMapping[id];\n                    const index = SUBSIGNAL_TO_INDEX[subsignal];\n                    if (index) {\n                        const lightMaterial = this.trafficMaterials[subsignal].LIGHT;\n                        const subsignalMesh = mesh.children[index];\n                        subsignalMesh.material = lightMaterial;\n                        subsignalMesh.subsignal = subsignal;\n                        this.signalStatusMeshs.push(subsignalMesh);\n                    }\n                }\n            });\n        }\n    }\n\n    drawTrafficSignals(signals) {\n        this.currentTrafficSignalIds = [];\n        if (!signals || signals.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.trafficBaseMeshTemplate) {\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        signals.forEach((signal) => {\n            const id = signal.id.id;\n            this.currentTrafficSignalIds.push(id);\n            if (this.baseSignalMeshs[id]) {\n                return;\n            }\n            let { position } = getPositionAndHeading(signal);\n            const { heading } = getPositionAndHeading(signal);\n            if (!position) {\n                return;\n            }\n            position = this.coordinates.applyOffset(position);\n            const mesh = this.trafficBaseMeshTemplate.clone();\n            mesh.rotation.y = heading || 0;\n            mesh.position.set(position.x, position.y, 0);\n            mesh.scale.set(TRAFFIC_LIGHT_SCALE, TRAFFIC_LIGHT_SCALE, TRAFFIC_LIGHT_SCALE);\n            this.baseSignalMeshs[signal.id.id] = mesh;\n            this.scene.add(mesh);\n\n            signal.stopLine.forEach((item) => {\n                const lines = drawStopLine(item, this.coordinates);\n                lines.forEach((line) => {\n                    this.stopLineMeshs[id] = this.stopLineMeshs[id] || [];\n                    this.stopLineMeshs[id].push(line);\n                    this.scene.add(line);\n                });\n            });\n        });\n        this.removeOldTrafficSignals();\n    }\n\n    dispose() {\n        Object.values(this.baseSignalMeshs).forEach((mesh) => {\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n        Object.keys(this.stopLineMeshs).forEach((id) => {\n            const meshArr = this.stopLineMeshs[id];\n            meshArr.forEach((item) => {\n                disposeMesh(item);\n                this.scene.remove(item);\n            });\n        });\n        this.baseSignalMeshs = {};\n        this.stopLineMeshs = {};\n        this.currentTrafficSignalIds = [];\n    }\n\n    clearSignalStatus() {\n        this.signalStatusMeshs.forEach((mesh) => {\n            const darkMaterial = this.trafficMaterials[mesh.subsignal].DARK;\n            if (darkMaterial) {\n                mesh.material = darkMaterial;\n            }\n        });\n        this.signalStatusMeshs = [];\n    }\n\n    removeOldTrafficSignals() {\n        const drawedTrafficSignalIds = Object.keys(this.baseSignalMeshs);\n        const needRemovedTrafficSignals = without(drawedTrafficSignalIds, ...this.currentTrafficSignalIds);\n        if (needRemovedTrafficSignals && needRemovedTrafficSignals.length) {\n            needRemovedTrafficSignals.forEach((id) => {\n                const removedSignal = this.baseSignalMeshs[id];\n                disposeMesh(removedSignal);\n                this.scene.remove(removedSignal);\n                delete this.baseSignalMeshs[id];\n\n                const stopLineMeshs = this.stopLineMeshs[id];\n                stopLineMeshs.forEach((item) => {\n                    disposeMesh(item);\n                    this.scene.remove(item);\n                });\n                delete this.stopLineMeshs[id];\n            });\n        }\n    }\n}\n","export default __webpack_public_path__ + \"5033c297a85516654b48ecd109848ba2.mtl\";","export default __webpack_public_path__ + \"10167062c9e9670a4a2070913d5d7622.obj\";","import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';\nimport * as THREE from 'three';\nimport { without } from 'lodash';\nimport stopSignMaterial from '../../../assets/models/stop_sign.mtl';\nimport stopSignObj from '../../../assets/models/stop_sign.obj';\nimport { drawStopLine } from '../../utils/stopLine';\nimport { disposeMesh } from '../../utils/common';\nimport { getHeadingFromStopLine } from '../../utils/signal';\n\nconst STOP_SIGN_SCALE = 0.01;\nexport default class StopSign {\n    private stopSignTemplate;\n\n    private scene;\n\n    private stopLineMeshs;\n\n    private stopSignMeshs;\n\n    private currentStopSignalIds;\n\n    private coordinates;\n\n    constructor(scene, coordinates) {\n        this.stopSignTemplate = null;\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.stopLineMeshs = {};\n        this.stopSignMeshs = {};\n        this.currentStopSignalIds = [];\n        this.initStopSignTemplate();\n    }\n\n    getPositionAndHeading(stopSign) {\n        if (!stopSign?.stopLine?.[0]) {\n            return {};\n        }\n        const heading = getHeadingFromStopLine(stopSign.stopLine[0]);\n\n        if (!Number.isNaN(heading)) {\n            const points = stopSign.stopLine?.[0].segment?.[0].lineSegment?.point;\n            const length = points.length;\n            const stopLinePoint = points[length - 1];\n            let position = new THREE.Vector3(stopLinePoint.x, stopLinePoint.y, 0);\n            position = this.coordinates.applyOffset(position);\n            return { position, heading };\n        }\n        return {};\n    }\n\n    initStopSignTemplate() {\n        const mtlLoader = new MTLLoader();\n        const objLoader = new OBJLoader();\n        mtlLoader.load(stopSignMaterial, (material) => {\n            material.preload();\n            objLoader.setMaterials(material);\n            objLoader.load(stopSignObj, (object) => {\n                object.rotateX(Math.PI / 2);\n                this.stopSignTemplate = object;\n            });\n        });\n    }\n\n    drawStopSigns(stopSigns) {\n        this.currentStopSignalIds = [];\n        if (!this.stopSignTemplate) {\n            return;\n        }\n        if (!stopSigns || stopSigns.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        stopSigns.forEach((stopSign) => {\n            const id = stopSign.id.id;\n            this.currentStopSignalIds.push(id);\n            if (this.stopSignMeshs[id]) {\n                return;\n            }\n\n            const mesh = this.stopSignTemplate.clone();\n            const { position, heading } = this.getPositionAndHeading(stopSign);\n            if (!position) {\n                return;\n            }\n\n            mesh.rotation.y = heading || 0;\n            mesh.position.set(position.x, position.y, 0);\n            mesh.scale.set(STOP_SIGN_SCALE, STOP_SIGN_SCALE, STOP_SIGN_SCALE);\n            this.stopSignMeshs[id] = mesh;\n            this.scene.add(mesh);\n\n            const stopLine = stopSign.stopLine;\n            if (stopLine) {\n                stopLine.forEach((item) => {\n                    const meshs = drawStopLine(item, this.coordinates);\n                    meshs.forEach((mesh) => {\n                        this.stopLineMeshs[id] = this.stopLineMeshs[id] || [];\n                        this.stopLineMeshs[id].push(mesh);\n                        this.scene.add(mesh);\n                    });\n                });\n            }\n        });\n        this.removeOldTrafficSignals();\n    }\n\n    dispose() {\n        Object.values(this.stopSignMeshs).forEach((mesh) => {\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n\n        Object.keys(this.stopLineMeshs).forEach((id) => {\n            const meshArr = this.stopLineMeshs[id];\n            meshArr.forEach((item) => {\n                disposeMesh(item);\n                this.scene.remove(item);\n            });\n        });\n\n        this.stopLineMeshs = {};\n        this.stopSignMeshs = {};\n        this.currentStopSignalIds = [];\n    }\n\n    removeOldTrafficSignals() {\n        const drawedStopSignalIds = Object.keys(this.stopSignMeshs);\n        const needRemovedStopSignals = without(drawedStopSignalIds, ...this.currentStopSignalIds);\n        if (needRemovedStopSignals && needRemovedStopSignals.length) {\n            needRemovedStopSignals.forEach((id) => {\n                const removedSignal = this.stopSignMeshs[id];\n                disposeMesh(removedSignal);\n                this.scene.remove(removedSignal);\n                delete this.stopSignMeshs[id];\n\n                const stopLineMeshs = this.stopLineMeshs[id];\n                stopLineMeshs.forEach((item) => {\n                    disposeMesh(item);\n                    this.scene.remove(item);\n                });\n                delete this.stopLineMeshs[id];\n            });\n        }\n    }\n}\n","import * as THREE from 'three';\nimport { without } from 'lodash';\nimport { drawSegmentsFromPoints } from '../../utils/line';\nimport { colorMapping, zOffset } from '../../constant/common';\nimport { disposeGroup } from '../../utils/common';\n\nexport default class SpeedBump {\n    private groups;\n\n    private scene;\n\n    private currentIds;\n\n    private coordinates;\n\n    constructor(scene, coordinates) {\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.groups = {};\n        this.currentIds = [];\n    }\n\n    drawSpeedBumps(speedBumps) {\n        this.currentIds = [];\n        if (!speedBumps || speedBumps.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        speedBumps.forEach((speedBump) => {\n            const id = speedBump.id.id;\n            this.currentIds.push(id);\n            if (this.groups[id]) {\n                return;\n            }\n            const lines = speedBump.position;\n            const group = new THREE.Group();\n            group.name = 'speedBump';\n            lines.forEach((line) => {\n                line.segment.forEach((segment) => {\n                    const points = this.coordinates.applyOffsetToArray(segment.lineSegment.point);\n                    const mesh = drawSegmentsFromPoints(points, {\n                        color: colorMapping.RED,\n                        linewidth: 5,\n                        zOffset: zOffset.speedBump,\n                        opacity: 1,\n                    });\n                    group.add(mesh);\n                });\n            });\n            this.groups[id] = group;\n            this.scene.add(group);\n        });\n    }\n\n    dispose() {\n        Object.values(this.groups).forEach((group) => {\n            disposeGroup(group);\n            this.scene.remove(group);\n        });\n        this.groups = [];\n        this.currentIds = [];\n    }\n\n    removeOldGroups() {\n        const needRemovedIds = without(Object.keys(this.groups), ...this.currentIds);\n        if (needRemovedIds && needRemovedIds.length) {\n            needRemovedIds.forEach((id) => {\n                const removedGroup = this.groups[id];\n                disposeGroup(removedGroup);\n                this.scene.remove(removedGroup);\n                delete this.groups[id];\n            });\n        }\n    }\n}\n","import { without } from 'lodash';\nimport { drawPolygon } from '../../utils/polygon';\nimport { colorMapping, zOffset } from '../../constant/common';\nimport { disposeMesh } from '../../utils/common';\n\nexport default class ParkingSpace {\n    private meshs;\n\n    private ids;\n\n    private scene;\n\n    private text;\n\n    private option;\n\n    private currentIds;\n\n    private coordinates;\n\n    constructor(scene, text, option, coordinates) {\n        this.scene = scene;\n        this.coordinates = coordinates;\n        this.option = option;\n        this.meshs = {};\n        this.ids = {};\n        this.text = text;\n        this.currentIds = [];\n    }\n\n    drawParkingSpaces(parkingSpaces) {\n        this.currentIds = [];\n        if (!parkingSpaces || parkingSpaces.length === 0) {\n            this.dispose();\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        parkingSpaces.forEach((parkingSpace) => {\n            const id = parkingSpace.id.id;\n            this.currentIds.push(id);\n            if (this.meshs[id]) {\n                return;\n            }\n            const points = this.coordinates.applyOffsetToArray(parkingSpace.polygon.point);\n            const mesh = drawPolygon(points, {\n                color: colorMapping.YELLOW,\n                linewidth: 2,\n                zOffset: zOffset.parkingSpace,\n                opacity: 1,\n                matrixAutoUpdate: true,\n            });\n            this.meshs[id] = mesh;\n            this.scene.add(mesh);\n\n            if (this.option.layerOption.Map.parkingSpaceId) {\n                this.drawParkingSpaceId(parkingSpace);\n            }\n        });\n        this.removeOldGroups();\n    }\n\n    drawParkingSpaceId(parkingSpace) {\n        const id = parkingSpace.id.id;\n        if (this.ids[id]) {\n            return;\n        }\n        const points = this.coordinates.applyOffsetToArray(parkingSpace?.polygon?.point);\n        if (points && points.length >= 3) {\n            const point1 = points[0];\n            const point2 = points[1];\n            const point3 = points[2];\n            const position = {\n                x: (point1.x + point3.x) / 2,\n                y: (point1.y + point3.y) / 2,\n                z: 0.04,\n            };\n            const rotationZ = Math.atan2(point2.y - point1.y, point2.x - point1.x);\n            const text = this.text.drawText(id, colorMapping.WHITE, position);\n            text.rotation.z = rotationZ;\n            this.ids[id] = text;\n            this.scene.add(text);\n        }\n    }\n\n    dispose() {\n        this.disposeParkingSpaceIds();\n        this.disposeParkingSpaces();\n    }\n\n    disposeParkingSpaces() {\n        Object.values(this.meshs).forEach((mesh) => {\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n        this.meshs = {};\n    }\n\n    disposeParkingSpaceIds() {\n        Object.values(this.ids).forEach((mesh) => {\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n        this.ids = {};\n        this.currentIds = [];\n    }\n\n    removeOldGroups() {\n        const needRemovedIds = without(Object.keys(this.meshs), ...this.currentIds);\n        if (needRemovedIds && needRemovedIds.length) {\n            needRemovedIds.forEach((id) => {\n                const removedMesh = this.meshs[id];\n                disposeMesh(removedMesh);\n                this.scene.remove(removedMesh);\n                delete this.meshs[id];\n\n                const text = this.ids[id];\n                disposeMesh(text);\n                this.scene.remove(text);\n                delete this.ids[id];\n            });\n        }\n    }\n}\n","import * as THREE from 'three';\nimport Lane from './lane';\nimport Junction from './junction';\nimport Grid from './grid';\nimport ClearArea from './clearArea';\nimport Crosswalk from './crosswalk';\nimport PncJunction from './pncJunction';\nimport Road from './road';\nimport YieldSignal from './yieldSignal';\nimport TrafficSignal from './trafficSignal';\nimport StopSign from './stopSign';\nimport SpeedBump from './speedBump';\nimport ParkingSpace from './parkingSpace';\n\nclass Map {\n    private scene;\n\n    public trafficSignal;\n\n    public stopSign;\n\n    public yieldSignal;\n\n    public clearArea;\n\n    public crosswalk;\n\n    public lane;\n\n    private text;\n\n    public junction;\n\n    public pncJunction;\n\n    public road;\n\n    public speedBump;\n\n    public parkingSpace;\n\n    public grid;\n\n    private option;\n\n    private coordinates;\n\n    constructor(scene, text, option, coordinates) {\n        this.scene = scene;\n        this.text = text;\n        this.option = option;\n        this.coordinates = coordinates;\n        this.trafficSignal = new TrafficSignal(scene, coordinates);\n        this.stopSign = new StopSign(scene, coordinates);\n        this.yieldSignal = new YieldSignal(scene, coordinates);\n        this.clearArea = new ClearArea(scene, coordinates);\n        this.crosswalk = new Crosswalk(scene, coordinates);\n        this.lane = new Lane(scene, text, option, coordinates);\n        this.junction = new Junction(scene, coordinates);\n        this.pncJunction = new PncJunction(scene, coordinates);\n        this.road = new Road(scene, coordinates);\n        this.speedBump = new SpeedBump(scene, coordinates);\n        this.parkingSpace = new ParkingSpace(scene, text, option, coordinates);\n        this.grid = new Grid(scene);\n    }\n\n    public update(mapData, removeOld = false) {\n        if (removeOld) {\n            this.dispose();\n        }\n        Object.keys(mapData).forEach((key) => {\n            const data = mapData[key];\n            const {\n                crosswalk,\n                clearArea,\n                junction,\n                pncJunction,\n                lane,\n                road,\n                signal,\n                stopSign,\n                yieldSign,\n                speedBump,\n                parkingSpace,\n            } = this.option.layerOption.Map;\n\n            // \n            if (!removeOld) {\n                if (!mapData.lane || !lane) {\n                    this.lane.dispose();\n                }\n                if (!mapData.junction || !junction) {\n                    this.junction.dispose();\n                }\n                if (!mapData.crosswalk || !crosswalk) {\n                    this.crosswalk.dispose();\n                }\n                if (!mapData.clearArea || !clearArea) {\n                    this.clearArea.dispose();\n                }\n                if (!mapData.pncJunction || !pncJunction) {\n                    this.pncJunction.dispose();\n                }\n                if (!mapData.road || !road) {\n                    this.road.dispose();\n                }\n                if (!mapData.stopSign || !stopSign) {\n                    this.stopSign.dispose();\n                }\n\n                if (!mapData.signal || !signal) {\n                    this.trafficSignal.dispose();\n                }\n                if (!mapData.speedBump || !speedBump) {\n                    this.speedBump.dispose();\n                }\n\n                if (!mapData.parkingSpace || !parkingSpace) {\n                    this.parkingSpace.dispose();\n                }\n            }\n\n            switch (key) {\n                case 'lane':\n                    if (lane) {\n                        this.lane.drawLanes(data);\n                    }\n                    break;\n                case 'junction':\n                    if (junction) {\n                        this.junction.drawJunctions(data);\n                    }\n                    break;\n                case 'crosswalk':\n                    if (crosswalk) {\n                        this.crosswalk.drawCrosswalk(data);\n                    }\n                    break;\n                case 'clearArea':\n                    if (clearArea) {\n                        this.clearArea.drawClearAreas(data);\n                    }\n                    break;\n                case 'pncJunction':\n                    if (pncJunction) {\n                        this.pncJunction.drawPncJunctions(data);\n                    }\n                    break;\n                case 'road':\n                    if (road) {\n                        this.road.drawRoads(data);\n                    }\n                    break;\n                case 'yield':\n                    if (yieldSign) {\n                        this.yieldSignal.drawYieldSigns(data);\n                    }\n                    break;\n                case 'signal':\n                    if (signal) {\n                        this.trafficSignal.drawTrafficSignals(data);\n                    }\n                    break;\n                case 'stopSign':\n                    if (stopSign) {\n                        this.stopSign.drawStopSigns(data);\n                    }\n                    break;\n                case 'speedBump':\n                    if (speedBump) {\n                        this.speedBump.drawSpeedBumps(data);\n                    }\n                    break;\n                case 'parkingSpace':\n                    if (parkingSpace) {\n                        this.parkingSpace.drawParkingSpaces(data);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        });\n        if (this.lane.currentLaneIds.length !== 0) {\n            const { width, height, center } = this.lane;\n            const size = Math.max(width, height);\n            const position = { x: center.x, y: center.y, z: 0 };\n\n            this.grid.drawGrid(\n                {\n                    size,\n                    divisions: size / 5,\n                    colorCenterLine: 0xffffff,\n                    colorGrid: 0xffffff,\n                },\n                position,\n            );\n        }\n    }\n\n    public updateTrafficStatus(signals) {\n        this.trafficSignal.updateTrafficStatus(signals);\n    }\n\n    public dispose() {\n        this.trafficSignal.dispose();\n        this.stopSign.dispose();\n        this.yieldSignal.dispose();\n        this.clearArea.dispose();\n        this.crosswalk.dispose();\n        this.lane.dispose();\n        this.junction.dispose();\n        this.pncJunction.dispose();\n        this.parkingSpace.dispose();\n        this.road.dispose();\n        this.speedBump.dispose();\n        this.grid.dispose();\n    }\n}\nexport default Map;\n","export default __webpack_public_path__ + \"5fbe9eaf9265cc5cbf665a59e3ca15b7.mtl\";","export default __webpack_public_path__ + \"0e93390ef55c539c9a069a917e8d9948.obj\";","import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';\nimport { isNumber } from 'lodash';\nimport carMaterial from '../../assets/models/car.mtl';\nimport carObject from '../../assets/models/car.obj';\n\nconst defaultVehicleSize = {\n    height: 1.48,\n    width: 2.11,\n    length: 4.933,\n};\nexport default class Adc {\n    public adc;\n\n    public shadowAdc;\n\n    public planningAdc;\n\n    public isInitialized;\n\n    private scene;\n\n    public vehicleParam;\n\n    private option;\n\n    public autoDrivingCar;\n\n    private coordinates;\n\n    constructor(scene, option, coordinates) {\n        this.scene = scene;\n        this.option = option;\n        this.adc = null;\n        this.shadowAdc = null;\n        this.planningAdc = null;\n        this.isInitialized = false;\n        this.autoDrivingCar = null;\n        this.vehicleParam = {\n            frontEdgeToCenter: 3.89,\n            backEdgeToCenter: 1.043,\n            leftEdgeToCenter: 1.055,\n            rightEdgeToCenter: 1.055,\n            height: 1.48,\n            width: 2.11,\n            length: 4.933,\n            steerRatio: 16,\n            wheelBase: 2.8448,\n        };\n        this.coordinates = coordinates;\n        this.init();\n    }\n\n    private init() {\n        const mtlLoader = new MTLLoader();\n        const objLoader = new OBJLoader();\n        objLoader.load(carObject, (object) => {\n            this.planningAdc = object.clone();\n            this.planningAdc.name = 'planningAdc';\n            this.planningAdc.rotation.x = Math.PI / 2;\n            this.planningAdc.visible = false;\n            this.shadowAdc = object.clone();\n            this.shadowAdc.name = 'shadowAdc';\n            this.shadowAdc.rotation.x = Math.PI / 2;\n            this.shadowAdc.visible = false;\n\n            this.scene.add(this.planningAdc);\n            this.scene.add(this.shadowAdc);\n        });\n        mtlLoader.load(carMaterial, (material) => {\n            material.preload();\n            objLoader.setMaterials(material);\n            objLoader.load(carObject, (object) => {\n                this.adc = object;\n                this.adc.name = 'adc';\n                this.adc.rotation.x = Math.PI / 2;\n                this.adc.visible = false;\n                this.scene.add(this.adc);\n            });\n        });\n    }\n\n    public update(pos, name) {\n        if (!this[name] || !pos || !isNumber(pos.positionX) || !isNumber(pos.positionY)) {\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            this.coordinates.initialize(pos.positionX, pos.positionY);\n        }\n        if (this[name] && pos) {\n            const { positionX, positionY, heading } = pos;\n            const position = this.coordinates.applyOffset({ x: positionX, y: positionY });\n            if (!position) {\n                return;\n            }\n            this[name].position.set(position.x, position.y, 0);\n            this[name].rotation.y = heading;\n            if (name === 'adc') {\n                this.adc.visible = this.option.layerOption.Position.localization;\n                this.autoDrivingCar = pos;\n            }\n            if (name === 'shadowAdc') {\n                this.shadowAdc.visible = this.option.layerOption.Position.shadow;\n            }\n            if (name === 'planningAdc') {\n                this.planningAdc.visible = this.option.layerOption.Planning.planningCar;\n            }\n        }\n    }\n\n    updateVehicleParam(params) {\n        this.vehicleParam = params;\n        this.resizeCarSize(\n            this.vehicleParam.length / defaultVehicleSize.length,\n            this.vehicleParam.height / defaultVehicleSize.height,\n            this.vehicleParam.width / defaultVehicleSize.width,\n        );\n    }\n\n    resizeCarSize(x, y, z) {\n        this.shadowAdc?.scale(x, y, z);\n        this.adc?.scale(x, y, z);\n        this.planningAdc?.scale(x, y, z);\n    }\n}\n","import * as THREE from 'three';\nimport { camelCase } from 'lodash';\nimport { obstacleColorMapping } from '../constant/common';\nimport { disposeMesh, drawArrow, drawImge, disposeGroup, drawBox, drawDashedBox, drawSolidBox } from '../utils/common';\nimport iconObjectYield from '../../assets/images/decision/object-yield.png';\n\nconst DEFAULT_HEIGHT = 1.5;\nenum ObjectType {\n    UNKNOWN = 0,\n    UNKNOWN_MOVABLE = 1,\n    UNKNOWN_UNMOVABLE = 2,\n    PEDESTRIAN = 3,\n    BICYCLE = 4,\n    VEHICLE = 5,\n    VIRTUAL = 6,\n    CIPV = 7,\n}\n\nfunction getSensorType(key) {\n    if (key.search('radar') !== -1) {\n        return 'RadarSensor';\n    }\n    if (key.search('lidar') !== -1 || key.search('velodyne') !== -1) {\n        return 'LidarSensor';\n    }\n    if (key.search('camera') !== -1) {\n        return 'CameraSensor';\n    }\n    return null;\n}\n\nexport default class Obstacles {\n    private obstacleMeshs;\n\n    private speedHeadingArrows;\n\n    private obstacleHeadingArrows;\n\n    private textMeshs;\n\n    private iconMeshs;\n\n    private iconMeshTemplate;\n\n    private scene;\n\n    private view;\n\n    private text;\n\n    private solidFaceCubeMeshTemplate;\n\n    private option;\n\n    private coordinates;\n\n    constructor(scene, view, text, option, coordinates) {\n        this.scene = scene;\n        this.view = view;\n        this.text = text;\n        this.option = option;\n        this.coordinates = coordinates;\n        this.obstacleMeshs = [];\n        this.speedHeadingArrows = [];\n        this.obstacleHeadingArrows = [];\n        this.textMeshs = [];\n        this.iconMeshs = [];\n        this.iconMeshTemplate = null;\n        this.solidFaceCubeMeshTemplate = null;\n\n        this.drawIconMeshTemplate();\n        this.drawCubeTemplate();\n    }\n\n    drawObstacleHeading(obstacle) {\n        const { height, positionX, positionY, heading } = obstacle;\n        const position = this.coordinates.applyOffset({ x: positionX, y: positionY });\n        const color = 0xffffff;\n        const arrowMesh = drawArrow(color);\n        arrowMesh.rotateZ(heading);\n        arrowMesh.position.set(position.x, position.y, (height || DEFAULT_HEIGHT) / 2);\n        return arrowMesh;\n    }\n\n    drawSpeedHeading(obstacle) {\n        const { height, positionX, positionY, type, speedHeading, speed } = obstacle;\n        const position = this.coordinates.applyOffset({ x: positionX, y: positionY });\n        const color = obstacleColorMapping[ObjectType[type]] || obstacleColorMapping.DEFAULT;\n        const arrowMesh = drawArrow(color);\n        arrowMesh.rotateZ(speedHeading);\n        const scale = 1 + Math.log2(speed);\n        arrowMesh.scale.set(scale, scale, scale);\n        arrowMesh.position.set(position.x, position.y, (height || DEFAULT_HEIGHT) / 2);\n        return arrowMesh;\n    }\n\n    drawTrafficCone(obstacle) {\n        const { positionX, positionY, positionZ } = obstacle;\n        const position = this.coordinates.applyOffset({ x: positionX, y: positionY });\n        const geometry = new THREE.CylinderGeometry(0.1, 0.25, 0.914, 32);\n        const material = new THREE.MeshBasicMaterial({\n            color: obstacleColorMapping.TRAFFICCONE,\n            transparent: true,\n            opacity: 0.64,\n        });\n        const mesh = new THREE.Mesh(geometry, material);\n        mesh.rotation.set(Math.PI / 2, 0, 0);\n        mesh.position.set(position.x, position.y, positionZ);\n        return mesh;\n    }\n\n    update(obstacles, measurements, autoDrivingCar) {\n        this.dispose();\n        this.updateObstacles(obstacles, autoDrivingCar);\n        this.updateSensorMeasurements(measurements);\n    }\n\n    updateObstacles(obstacles, autoDrivingCar) {\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        const { obstacleHeading, obstacleDistanceAndSpeed } = this.option.layerOption.Perception;\n        for (let i = 0; i < obstacles.length; i += 1) {\n            const obstacle = obstacles[i];\n            const { positionX, positionY, yieldedobstacle, type } = obstacle;\n            if (!positionX || !positionY) {\n                continue;\n            }\n            if (!this.option.layerOption.Perception[camelCase(ObjectType[type])]) {\n                continue;\n            }\n\n            const mesh = this.drawObstacle(obstacle);\n            if (!mesh) {\n                return;\n            }\n            if (mesh) {\n                this.scene.add(mesh);\n                this.obstacleMeshs.push(mesh);\n            }\n\n            if (obstacleHeading) {\n                const obstacleHeadingArrow = this.drawObstacleHeading(obstacle);\n                if (obstacleHeadingArrow) {\n                    this.obstacleHeadingArrows.push(obstacleHeadingArrow);\n                    this.scene.add(obstacleHeadingArrow);\n                }\n            }\n\n            if (obstacleDistanceAndSpeed) {\n                const speedHeadingArrow = this.drawSpeedHeading(obstacle);\n                if (speedHeadingArrow) {\n                    this.speedHeadingArrows.push(speedHeadingArrow);\n                    this.scene.add(speedHeadingArrow);\n                }\n            }\n\n            if (yieldedobstacle) {\n                const icon = this.iconMeshTemplate.clone();\n                let position = new THREE.Vector3(positionX, positionY, (obstacle.height || DEFAULT_HEIGHT) + 0.5);\n                position = this.coordinates.applyOffset(position);\n                icon.position.set(position.x, position.y, position.z);\n                this.scene.add(icon);\n                this.iconMeshs.push(icon);\n            }\n            const texts = this.drawTexts(obstacle, autoDrivingCar);\n            texts.forEach((mesh) => {\n                this.textMeshs.push(mesh);\n                this.scene.add(mesh);\n            });\n        }\n    }\n\n    updateSensorMeasurements(sensorMeasurements) {\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        const { lidar, radar, camera, obstacleHeading } = this.option.layerOption.Perception;\n        if (!lidar && !radar && !camera) {\n            return;\n        }\n        if (!sensorMeasurements) {\n            return;\n        }\n        Object.keys(sensorMeasurements).forEach((key) => {\n            const sensorType = getSensorType(key.toLowerCase());\n            if (!sensorType || !this.option.layerOption.Perception[sensorType]) {\n                return;\n            }\n            const measurements = sensorMeasurements[key]?.sensorMeasurement;\n            if (!measurements || measurements.length === 0) {\n                return;\n            }\n            measurements.forEach((item) => {\n                if (!item.positionX || !item.positionY) {\n                    return;\n                }\n                if (obstacleHeading) {\n                    const obstacleHeadingArrow = this.drawObstacleHeading(item);\n                    this.obstacleHeadingArrows.push(obstacleHeadingArrow);\n                    this.scene.add(obstacleHeadingArrow);\n                }\n                const mesh = this.drawObstacle(item);\n                if (mesh) {\n                    this.scene.add(mesh);\n                    this.obstacleMeshs.push(mesh);\n                }\n            });\n        });\n    }\n\n    dispose() {\n        [\n            ...this.obstacleHeadingArrows,\n            ...this.speedHeadingArrows,\n            ...this.obstacleMeshs,\n            ...this.textMeshs,\n            ...this.iconMeshs,\n        ].forEach((mesh) => {\n            if (mesh.type === 'Group') {\n                disposeGroup(mesh);\n            } else {\n                disposeMesh(mesh);\n            }\n            this.scene.remove(mesh);\n        });\n        this.speedHeadingArrows = [];\n        this.obstacleHeadingArrows = [];\n        this.obstacleMeshs = [];\n        this.iconMeshs = [];\n        this.textMeshs = [];\n        this.text.reset();\n    }\n\n    drawIconMeshTemplate() {\n        const mesh = drawImge(iconObjectYield, 1, 1);\n        this.iconMeshTemplate = mesh;\n    }\n\n    drawCubeTemplate() {\n        const color = obstacleColorMapping.DEFAULT;\n        const solidFaceCube = drawSolidBox(1, 1, 1, color);\n        this.solidFaceCubeMeshTemplate = solidFaceCube;\n    }\n\n    drawObstaclePolygon(obstacle) {\n        const { polygonPoint, height, confidence, source, type } = obstacle;\n        const bottomPoints = this.coordinates.applyOffsetToArray(polygonPoint);\n        const color = obstacleColorMapping[ObjectType[type]] || obstacleColorMapping.DEFAULT;\n        const material = new THREE.LineBasicMaterial({\n            color,\n        });\n        const dashMaterial = new THREE.LineDashedMaterial({ color });\n        const isV2x = source === 'v2x';\n\n        const group = new THREE.Group();\n        // \n        const bottomGeometry = new THREE.BufferGeometry().setFromPoints(bottomPoints);\n        const bottomFace = new THREE.LineLoop(bottomGeometry, material);\n        group.add(bottomFace);\n        if (isV2x) {\n            // \n            const topPoints = bottomPoints.map((item) => new THREE.Vector3(item.x, item.y, item.z + height));\n            const topGeometry = new THREE.BufferGeometry().setFromPoints(topPoints);\n            const topFace = new THREE.LineLoop(topGeometry, material);\n            group.add(topFace);\n            // \n            for (let i = 0; i < topPoints.length; i += 1) {\n                const geometry = new THREE.BufferGeometry().setFromPoints([topPoints[i], bottomPoints[i]]);\n                const segmentMesh = new THREE.LineSegments(geometry, material);\n                group.add(segmentMesh);\n            }\n        } else {\n            // \n            const solidTopPoints = bottomPoints.map(\n                (item) => new THREE.Vector3(item.x, item.y, item.z + confidence * height),\n            );\n            const solidTopGeometry = new THREE.BufferGeometry().setFromPoints(solidTopPoints);\n            const solidTopFace = new THREE.LineLoop(solidTopGeometry, material);\n            group.add(solidTopFace);\n            // \n            for (let i = 0; i < solidTopPoints.length; i += 1) {\n                const geometry = new THREE.BufferGeometry().setFromPoints([solidTopPoints[i], bottomPoints[i]]);\n                const segmentMesh = new THREE.LineSegments(geometry, material);\n                group.add(segmentMesh);\n            }\n            if (confidence < 1) {\n                // \n                const dashTopPoints = bottomPoints.map((item) => new THREE.Vector3(item.x, item.y, item.z + height));\n                const dashTopGeometry = new THREE.BufferGeometry().setFromPoints(dashTopPoints);\n                const dashTopFace = new THREE.LineLoop(dashTopGeometry, dashMaterial);\n                group.add(dashTopFace);\n                // \n                for (let i = 0; i < solidTopPoints.length; i += 1) {\n                    const geometry = new THREE.BufferGeometry().setFromPoints([dashTopPoints[i], solidTopPoints[i]]);\n                    const segmentMesh = new THREE.LineSegments(geometry, dashMaterial);\n                    group.add(segmentMesh);\n                }\n            }\n        }\n        return group;\n    }\n\n    drawObstacle(obstacle) {\n        const { polygonPoint, length, width, height, source } = obstacle;\n        const isV2x = source === 'v2x';\n        let mesh = null;\n        if (obstacle.subType === 'ST_TRAFFICCONE') {\n            mesh = this.drawTrafficCone(obstacle);\n        } else if (polygonPoint && polygonPoint.length > 0 && this.option.layerOption.Perception.polygon) {\n            mesh = this.drawObstaclePolygon(obstacle);\n        } else if (length && width && height && this.option.layerOption.Perception.boundingbox) {\n            if (isV2x) {\n                mesh = this.drawV2xCube(obstacle);\n            } else {\n                mesh = this.drawCube(obstacle);\n            }\n        }\n        return mesh;\n    }\n\n    drawV2xCube(obstacle) {\n        const { length, width, height, positionX, positionY, type, heading } = obstacle;\n        const color = obstacleColorMapping[ObjectType[type]] || obstacleColorMapping.DEFAULT;\n        const v2XCubeMesh = this.solidFaceCubeMeshTemplate.clone();\n        const position = this.coordinates.applyOffset({\n            x: positionX,\n            y: positionY,\n            z: (obstacle.height || DEFAULT_HEIGHT) / 2,\n        });\n        v2XCubeMesh.scale.set(length, width, height);\n        v2XCubeMesh.position.set(position.x, position.y, position.z);\n        v2XCubeMesh.material.color.setHex(color);\n        v2XCubeMesh.children[0].material.color.setHex(color);\n        v2XCubeMesh.rotation.set(0, 0, heading);\n        return v2XCubeMesh;\n    }\n\n    drawCube(obstacle) {\n        const group = new THREE.Group();\n        const { length, width, height, positionX, positionY, type, heading, confidence = 0.5 } = obstacle;\n        const color = obstacleColorMapping[ObjectType[type]] || obstacleColorMapping.DEFAULT;\n        const position = this.coordinates.applyOffset({\n            x: positionX,\n            y: positionY,\n        });\n        if (confidence > 0) {\n            const solidBox = drawBox(length, width, height * confidence, color);\n            solidBox.position.z = ((height || DEFAULT_HEIGHT) / 2) * confidence;\n            group.add(solidBox);\n        }\n        if (confidence < 1) {\n            const dashBox = drawDashedBox(length, width, height * (1 - confidence), color);\n            dashBox.position.z = ((height || DEFAULT_HEIGHT) / 2) * (1 - confidence);\n            group.add(dashBox);\n        }\n        group.position.set(position.x, position.y, 0);\n        group.rotation.set(0, 0, heading);\n        return group;\n    }\n\n    drawTexts(obstacle, autoDrivingCar) {\n        const { positionX, positionY, height, id, source } = obstacle;\n        const { obstacleDistanceAndSpeed, obstacleId, obstaclePriority, obstacleInteractiveTag, v2x } =\n            this.option.layerOption.Perception;\n        const isBirdView = this.view.viewType === 'Overhead' || this.view.viewType === 'Map';\n        const isV2x = source === 'v2x';\n        const textMeshs = [];\n        const { positionX: adcX, positionY: adcY, heading: adcHeading } = autoDrivingCar;\n        const adcPosition = new THREE.Vector3(adcX, adcY, 0);\n        const obstaclePosition = new THREE.Vector3(positionX, positionY, (height || DEFAULT_HEIGHT) / 2);\n        const initPosition = this.coordinates.applyOffset({\n            x: positionX,\n            y: positionY,\n            z: height || DEFAULT_HEIGHT,\n        });\n        const lineSpacing = 0.5;\n        const deltaX = isBirdView ? 0.0 : lineSpacing * Math.cos(adcHeading);\n        const deltaY = isBirdView ? 0.7 : lineSpacing * Math.sin(adcHeading);\n        const deltaZ = isBirdView ? 0.0 : lineSpacing;\n        let lineCount = 0;\n\n        if (obstacleDistanceAndSpeed) {\n            const distance = adcPosition.distanceTo(obstaclePosition).toFixed(1);\n            const speed = obstacle.speed.toFixed(1);\n            const speedAndDistanceText = this.text.drawText(`(${distance}m,${speed}m/s)`, 0xffea00, initPosition);\n            if (speedAndDistanceText) {\n                textMeshs.push(speedAndDistanceText);\n                lineCount += 1;\n            }\n        }\n\n        if (obstacleId) {\n            const idPosition = {\n                x: initPosition.x + lineCount * deltaX,\n                y: initPosition.y + lineCount * deltaY,\n                z: initPosition.z + lineCount * deltaZ,\n            };\n            const idText = this.text.drawText(id, 0xffea00, idPosition);\n            if (idText) {\n                textMeshs.push(idText);\n                lineCount += 1;\n            }\n        }\n\n        if (obstaclePriority) {\n            const priority = obstacle.obstaclePriority?.priority;\n            if (priority && priority !== 'NORMAL') {\n                const priorityPosition = {\n                    x: initPosition.x + lineCount * deltaX,\n                    y: initPosition.y + lineCount * deltaY,\n                    z: initPosition.z + lineCount * deltaZ,\n                };\n                const priorityText = this.text.drawText(priority, 0xffea00, priorityPosition);\n                if (priorityText) {\n                    textMeshs.push(priorityText);\n                    lineCount += 1;\n                }\n            }\n        }\n\n        if (obstacleInteractiveTag) {\n            const interactiveTag = obstacle.interactiveTag?.interactiveTag;\n            if (interactiveTag && interactiveTag !== 'NONINTERACTION') {\n                const interactiveTagPosition = {\n                    x: initPosition.x + lineCount * deltaX,\n                    y: initPosition.y + lineCount * deltaY,\n                    z: initPosition.z + lineCount * deltaZ,\n                };\n                const interactiveTagText = this.text.drawText(interactiveTag, 0xffea00, interactiveTagPosition);\n                if (interactiveTagText) {\n                    textMeshs.push(interactiveTagText);\n                    lineCount += 1;\n                }\n            }\n        }\n\n        if (isV2x && v2x) {\n            const v2xType = obstacle.v2xInfo?.v2xType;\n            if (v2xType) {\n                v2xType.forEach((t) => {\n                    const v2xTypePosition = {\n                        x: initPosition.x + lineCount * deltaX,\n                        y: initPosition.y + lineCount * deltaY,\n                        z: initPosition.z + lineCount * deltaZ,\n                    };\n                    const v2xTypeText = this.text.drawText(t, 0xffea00, v2xTypePosition);\n                    if (v2xTypeText) {\n                        textMeshs.push(v2xTypeText);\n                        lineCount += 1;\n                    }\n                });\n            }\n        }\n        return textMeshs;\n    }\n}\n","import * as THREE from 'three';\nimport { FontLoader } from 'three/examples/jsm/loaders/FontLoader';\nimport { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry';\nimport { map } from 'lodash';\nimport fontJson from '../../assets/fonts/gentilis_bold.typeface.json';\n\nconst fonts: any = {};\nlet fontsLoaded = false;\nconst loader = new FontLoader();\nconst font = loader.parse(fontJson);\nfonts.gentilis_bold = font;\nfontsLoaded = true;\n\nexport const TEXT_ALIGN = {\n    CENTER: 'center',\n    LEFT: 'left',\n};\n\nconst LETTER_OFFSET = 0.05;\n\nexport default class Text3D {\n    private charMeshes;\n\n    private charWidths;\n\n    private charPointers;\n\n    private camera;\n\n    constructor(camera) {\n        this.charMeshes = {};\n        this.charPointers = {};\n        this.charWidths = {};\n        this.camera = camera;\n    }\n\n    reset() {\n        this.charPointers = {};\n    }\n\n    drawText(text, color, position) {\n        const textMesh = this.composeText(text, color);\n        if (textMesh === null) {\n            return null;\n        }\n        if (this.camera !== undefined) {\n            textMesh.quaternion.copy(this.camera.quaternion);\n        }\n        // eslint-disable-next-line no-return-assign\n        textMesh.children.forEach((c) => (c.visible = true));\n        textMesh.visible = true;\n        textMesh.position.set(position.x, position.y, position.z || 0);\n        return textMesh;\n    }\n\n    composeText(text, color) {\n        if (!fontsLoaded) {\n            return null;\n        }\n        // 32 is the ASCII code for white space.\n        const charIndices = map(text, (l) => l.charCodeAt(0) - 32);\n        const textMesh = new THREE.Object3D();\n        let offsetSum = 0;\n\n        for (let j = 0; j < charIndices.length; j += 1) {\n            const idx = charIndices[j];\n            let pIdx = this.charPointers[idx];\n            if (pIdx === undefined) {\n                pIdx = 0;\n                this.charPointers[idx] = pIdx;\n            }\n            if (this.charMeshes[idx] === undefined) {\n                this.charMeshes[idx] = [];\n            }\n            let mesh = this.charMeshes[idx][pIdx];\n            if (mesh === undefined) {\n                if (this.charMeshes[idx].length > 0) {\n                    mesh = this.charMeshes[idx][0].clone();\n                } else {\n                    const { charMesh, charWidth } = this.drawChar3D(text[j], color);\n                    mesh = charMesh;\n                    this.charWidths[idx] = Number.isFinite(charWidth) ? charWidth : 0.2;\n                }\n                this.charMeshes[idx].push(mesh);\n            }\n\n            mesh.position.set(offsetSum, 0, 0);\n            offsetSum = offsetSum + this.charWidths[idx] + LETTER_OFFSET;\n            this.charPointers[idx] += 1;\n            textMesh.add(mesh);\n        }\n\n        const offset = offsetSum / 2;\n        textMesh.children.forEach((child) => {\n            child.position.setX(child.position.x - offset);\n        });\n\n        return textMesh;\n    }\n\n    drawChar3D(char, color, font = fonts.gentilis_bold, size = 0.6, height = 0) {\n        const charGeo = new TextGeometry(char, {\n            font,\n            size,\n            height,\n        });\n        const charMaterial = new THREE.MeshBasicMaterial({ color });\n        const charMesh = new THREE.Mesh(charGeo, charMaterial);\n\n        charGeo.computeBoundingBox();\n        const { max, min } = charGeo.boundingBox;\n\n        return { charMesh, charWidth: max.x - min.x };\n    }\n}\n","import * as THREE from 'three';\nimport { pointCloudHeightColorMapping } from '../constant/common';\nimport { disposeMesh } from '../utils/common';\n\nconst MAX_POINTS = 200000;\n\nexport default class PointCloud {\n    private pointCloudMesh;\n\n    private scene;\n\n    private option;\n\n    private adc;\n\n    constructor(scene, adc, option) {\n        this.scene = scene;\n        this.adc = adc;\n        this.option = option;\n        this.pointCloudMesh = null;\n    }\n\n    update(pointCloud) {\n        this.dispose();\n        if (!this.option.layerOption.Perception.pointCloud) {\n            return;\n        }\n        if (!pointCloud.num || pointCloud.num.length % 3 !== 0) {\n            console.warn('pointCloud length should be multiples of 3');\n            return;\n        }\n        const adcMesh = this.adc?.adc || {};\n        const { x = 0, y = 0 } = adcMesh.position;\n        const heading = adcMesh?.rotation?.y || 0;\n\n        const pointCloudSize = pointCloud.num.length / 3;\n        const total = pointCloudSize < MAX_POINTS ? pointCloudSize : MAX_POINTS;\n        let colorKey = 0.5;\n        const positions = [];\n        const colors = [];\n        const geometry = new THREE.BufferGeometry();\n        for (let i = 0; i < total; i += 1) {\n            const x = pointCloud.num[i * 3];\n            const y = pointCloud.num[i * 3 + 1];\n            const z = pointCloud.num[i * 3 + 2];\n            positions.push(x, y, z);\n\n            if (z < 0.5) {\n                colorKey = 0.5;\n            } else if (z < 1.0) {\n                colorKey = 1.0;\n            } else if (z < 1.5) {\n                colorKey = 1.5;\n            } else if (z < 2.0) {\n                colorKey = 2.0;\n            } else if (z < 2.5) {\n                colorKey = 2.5;\n            } else if (z < 3.0) {\n                colorKey = 3.0;\n            } else {\n                colorKey = 10.0;\n            }\n            const color = new THREE.Color(pointCloudHeightColorMapping[colorKey]);\n            colors.push(color.r, color.g, color.b);\n        }\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n        const material = new THREE.PointsMaterial({\n            size: 0.25,\n            vertexColors: true,\n            transparent: true,\n            opacity: 0.7,\n        });\n        const pointCloudMesh = new THREE.Points(geometry, material);\n        pointCloudMesh.position.x = x;\n        pointCloudMesh.position.y = y;\n        pointCloudMesh.rotateZ(heading);\n        this.pointCloudMesh = pointCloudMesh;\n        this.scene.add(pointCloudMesh);\n    }\n\n    dispose() {\n        disposeMesh(this.pointCloudMesh);\n        this.scene.remove(this.pointCloudMesh);\n        this.pointCloudMesh = null;\n    }\n}\n","import { disposeMesh, drawThickBandFromPoints } from '../utils/common';\nimport { zOffset } from '../constant/common';\n\nexport default class Routing {\n    private routePathMeshs;\n\n    private scene;\n\n    private lastRoutingTime;\n\n    private option;\n\n    private coordinates;\n\n    constructor(scene, option, coordinates) {\n        this.routePathMeshs = [];\n        this.scene = scene;\n        this.option = option;\n        this.coordinates = coordinates;\n        this.lastRoutingTime = -1;\n    }\n\n    update(routingTime, routePath) {\n        if (!this.option.layerOption.Routing.routingLine) {\n            this.dispose();\n            return;\n        }\n        if (this.lastRoutingTime === routingTime || !routePath || routePath.length === 0) {\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        this.lastRoutingTime = routingTime;\n        this.dispose();\n\n        routePath.forEach((path) => {\n            let points = path.point || [];\n            if (points.length !== 0) {\n                points = this.coordinates.applyOffsetToArray(points);\n                const pathMesh = drawThickBandFromPoints(points, {\n                    color: 0xff0000,\n                    opacity: 0.6,\n                    lineWidth: 0.3,\n                });\n                if (pathMesh) {\n                    pathMesh.position.z = zOffset.routing;\n                    this.scene.add(pathMesh);\n                    this.routePathMeshs.push(pathMesh);\n                }\n            }\n        });\n    }\n\n    dispose() {\n        if (this.routePathMeshs.length) {\n            this.routePathMeshs.forEach((path) => {\n                disposeMesh(path);\n                this.scene.remove(path);\n            });\n            this.routePathMeshs = [];\n        }\n    }\n}\n","import * as THREE from 'three';\nimport { disposeGroup, disposeMesh, drawImge, drawShapeFromPoints } from '../utils/common';\nimport { drawDashedLineFromPoints } from '../utils/line';\nimport {\n    mainDecisionChangeLaneMarkerMapping,\n    mainDecisionStopReasonMarkerMapping,\n    decisionMarkerColorMapping,\n    obstacleDecisionIconMapping,\n    decisionFenceMapping,\n} from '../constant/common';\n\nexport default class Decision {\n    private fenceMeshMapping;\n\n    private iconMeshMapping;\n\n    private mainStopReasonMeshMapping;\n\n    private mainChangeLaneMeshMapping;\n\n    private mainDecisionGroups;\n\n    private obstacleDecisionGroupsAndMeshs;\n\n    private scene;\n\n    private option;\n\n    private coordinates;\n\n    constructor(scene, option, coordinates) {\n        this.scene = scene;\n        this.option = option;\n        this.coordinates = coordinates;\n        this.fenceMeshMapping = {};\n        this.iconMeshMapping = {};\n        this.mainChangeLaneMeshMapping = {};\n        this.mainStopReasonMeshMapping = {};\n        this.mainDecisionGroups = [];\n        this.obstacleDecisionGroupsAndMeshs = [];\n\n        this.initFenceMesh();\n        this.initIconMesh();\n        this.initMainStopReasonMesh();\n        this.initMainChangeLaneMesh();\n    }\n\n    update(mainDecision, obstacles) {\n        const { mainDecision: mainDecisionVisible, obstacleDecision: obstacleDecisionVisible } =\n            this.option.layerOption.Decision;\n        this.disposeMainDecisionMeshs();\n        this.disposeObstacleDecisionMeshs();\n        if (mainDecisionVisible) {\n            this.updateMainDecision(mainDecision);\n        }\n        if (obstacleDecisionVisible) {\n            this.updateObstacleDecision(obstacles);\n        }\n    }\n\n    updateMainDecision(mainDecision) {\n        this.disposeMainDecisionMeshs();\n        if (!this.option.layerOption.Decision.mainDecision) {\n            return;\n        }\n\n        if (Object.keys(mainDecision).length === 0) {\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        const { positionX, positionY, heading, decision } = mainDecision;\n        const position = this.coordinates.applyOffset(new THREE.Vector3(positionX, positionY, 0.2));\n        for (let i = 0; i < decision.length; i += 1) {\n            const dec = decision[i];\n            const { stopReason, changeLaneType } = dec;\n            const group = new THREE.Group();\n            if (stopReason) {\n                if (this.mainStopReasonMeshMapping[stopReason]) {\n                    const mesh = this.mainStopReasonMeshMapping[stopReason].clone();\n                    mesh.position.set(4.2, 3.6, 0);\n                    group.add(mesh);\n                }\n                if (this.fenceMeshMapping.MAIN_STOP) {\n                    const fence = this.fenceMeshMapping.MAIN_STOP.clone();\n                    fence.position.set(0, 1.5, 0);\n                    group.add(fence);\n                }\n\n                if (this.iconMeshMapping.MAIN_STOP) {\n                    const icon = this.iconMeshMapping.MAIN_STOP.clone();\n                    icon.position.set(3, 3.6, 0);\n                    group.add(icon);\n                }\n            }\n\n            if (changeLaneType) {\n                if (this.mainChangeLaneMeshMapping[changeLaneType]) {\n                    const mesh = this.mainChangeLaneMeshMapping[changeLaneType].clone();\n                    mesh.position.set(1.0, 2.8, 0);\n                    group.add(mesh);\n                }\n            }\n            group.position.set(position.x, position.y, position.z);\n            group.rotation.set(Math.PI / 2, heading - Math.PI / 2, 0);\n            this.mainDecisionGroups.push(group);\n            this.scene.add(group);\n        }\n    }\n\n    updateObstacleDecision(obstacles) {\n        this.disposeObstacleDecisionMeshs();\n        if (!this.option.layerOption.Decision.obstacleDecision) {\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        for (let i = 0; i < obstacles.length; i += 1) {\n            const obstacle = obstacles[i];\n            const decisions = obstacle.decision;\n            if (!decisions || decisions.length === 0) {\n                continue;\n            }\n            for (let j = 0; j < decisions.length; j += 1) {\n                const decision = decisions[j];\n                const { type, positionX, positionY, heading, polygonPoint } = decision;\n                const position = this.coordinates.applyOffset({ x: positionX, y: positionY });\n                if (!type) {\n                    continue;\n                }\n\n                const group = new THREE.Group();\n                if (type === 'STOP' || type === 'FOLLOW' || type === 'YIELD' || type === 'OVERTAKE') {\n                    const fence = this.fenceMeshMapping[type].clone();\n                    if (fence) {\n                        fence.position.set(0, 1.5, 0);\n                        group.add(fence);\n                    }\n\n                    const icon = this.iconMeshMapping[type].clone();\n                    if (icon) {\n                        icon.position.set(3, 3.6, 0);\n                        group.add(icon);\n                    }\n\n                    if (type === 'YIELD' || type === 'OVERTAKE') {\n                        if (!obstacle.positionX || !obstacle.positionY) {\n                            continue;\n                        }\n                        const color = decisionMarkerColorMapping[type];\n                        const points = [\n                            new THREE.Vector3(obstacle.positionX - positionX, obstacle.positionY - positionY, 0),\n                            new THREE.Vector3(0, 0, 0),\n                        ];\n                        const line = drawDashedLineFromPoints(points, {\n                            color,\n                            linewidth: 2,\n                            dashSize: 2,\n                            gapSize: 1,\n                            zOffset: 30,\n                            opacity: 1,\n                            matrixAutoUpdate: true,\n                        });\n                        line.computeLineDistances();\n                        line.rotation.set(-Math.PI / 2, heading - Math.PI / 2, 0);\n                        group.add(line);\n                    }\n                    group.rotation.set(Math.PI / 2, heading - Math.PI / 2, 0);\n                    group.position.set(position.x, position.y, 0);\n                    this.obstacleDecisionGroupsAndMeshs.push(group);\n                    this.scene.add(group);\n                } else if (type === 'NUDGE') {\n                    let points = polygonPoint.map((p) => new THREE.Vector3(p.x, p.y, p.z || 0));\n                    points = this.coordinates.applyOffsetToArray(points);\n                    const nudgeMesh = drawShapeFromPoints(points, 0xff7f00);\n                    this.obstacleDecisionGroupsAndMeshs.push(nudgeMesh);\n                    this.scene.add(nudgeMesh);\n                }\n            }\n        }\n    }\n\n    initFenceMesh() {\n        Object.keys(decisionFenceMapping).forEach((type) => {\n            const image = decisionFenceMapping[type];\n            const mesh = drawImge(image, 11.625, 3);\n            this.fenceMeshMapping[type] = mesh;\n        });\n    }\n\n    initIconMesh() {\n        Object.keys(obstacleDecisionIconMapping).forEach((type) => {\n            const image = obstacleDecisionIconMapping[type];\n            const mesh = drawImge(image, 1, 1);\n            this.iconMeshMapping[type] = mesh;\n        });\n    }\n\n    initMainStopReasonMesh() {\n        Object.keys(mainDecisionStopReasonMarkerMapping).forEach((type) => {\n            const image = mainDecisionStopReasonMarkerMapping[type];\n            const mesh = drawImge(image, 1, 1);\n            this.mainStopReasonMeshMapping[type] = mesh;\n        });\n    }\n\n    initMainChangeLaneMesh() {\n        Object.keys(mainDecisionChangeLaneMarkerMapping).forEach((type) => {\n            const image = mainDecisionChangeLaneMarkerMapping[type];\n            const mesh = drawImge(image, 1, 1);\n            this.mainChangeLaneMeshMapping[type] = mesh;\n        });\n    }\n\n    disposeMainDecisionMeshs() {\n        this.mainDecisionGroups.forEach((group) => {\n            disposeGroup(group);\n            this.scene.remove(group);\n        });\n        this.mainDecisionGroups = [];\n    }\n\n    disposeObstacleDecisionMeshs() {\n        this.obstacleDecisionGroupsAndMeshs.forEach((object) => {\n            if (object.type === 'Group') {\n                disposeGroup(object);\n            } else {\n                disposeMesh(object);\n            }\n            this.scene.remove(object);\n        });\n        this.obstacleDecisionGroupsAndMeshs = [];\n    }\n\n    dispose() {\n        this.disposeMainDecisionMeshs();\n        this.disposeObstacleDecisionMeshs();\n    }\n}\n","import { sortBy } from 'lodash';\nimport * as THREE from 'three';\nimport { disposeMesh, drawEllipseGeometry, drawCircle } from '../utils/common';\nimport { drawSegmentsFromPoints } from '../utils/line';\nimport { obstacleColorMapping, zOffset } from '../constant/common';\n\nconst EPSILON = 1e-3;\n\nexport default class Prediction {\n    private majorMeshs;\n\n    private minorMeshs;\n\n    private guassMeshs;\n\n    private scene;\n\n    private option;\n\n    private coordinates;\n\n    constructor(scene, option, coordinates) {\n        this.majorMeshs = [];\n        this.minorMeshs = [];\n        this.guassMeshs = [];\n        this.scene = scene;\n        this.option = option;\n        this.coordinates = coordinates;\n    }\n\n    update(obstacles) {\n        const { majorPredictionLine, minorPredictionLine } = this.option.layerOption.Prediction;\n        this.dispose();\n        if (majorPredictionLine) {\n            this.updateMajorPrediction(obstacles);\n        }\n        if (minorPredictionLine) {\n            this.updateMinorPrediction(obstacles);\n        }\n    }\n\n    updateMajorPrediction(obstacles) {\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        for (let i = 0; i < obstacles.length; i += 1) {\n            const obstacle = obstacles[i];\n            const predictions = obstacle.prediction;\n            const color = obstacleColorMapping[obstacle.type] || obstacleColorMapping.DEFAULT;\n            if (!predictions || predictions.length === 0) {\n                continue;\n            }\n\n            sortBy(predictions, (o) => o.probability);\n            const majorPrediction = predictions[predictions.length - 1];\n            const points = this.coordinates.applyOffsetToArray(majorPrediction.predictedTrajectory);\n            const mesh = drawSegmentsFromPoints(points, {\n                color,\n                linewidth: 3,\n                zOffset: zOffset.prediction,\n                opacity: 1,\n                matrixAutoUpdate: true,\n            });\n            this.majorMeshs.push(mesh);\n            this.scene.add(mesh);\n\n            for (let j = 0; j < points.length; j += 1) {\n                const point = points[j];\n                const circleMesh = this.drawCircle();\n                circleMesh.position.set(point.x, point.y, zOffset.prediction);\n                circleMesh.material.color.setHex(color);\n                this.majorMeshs.push(circleMesh);\n                this.scene.add(circleMesh);\n\n                if (this.option.layerOption.Prediction.gaussianInfo) {\n                    const gaussianMesh = this.drawGaussian(point.gaussianInfo, color);\n                    if (gaussianMesh) {\n                        this.guassMeshs.push(gaussianMesh);\n                        this.scene.add(gaussianMesh);\n                    }\n                }\n            }\n        }\n    }\n\n    updateMinorPrediction(obstacles) {\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        for (let i = 0; i < obstacles.length; i += 1) {\n            const obstacle = obstacles[i];\n            const predictions = obstacle.prediction;\n            const color = obstacleColorMapping[obstacle.type] || obstacleColorMapping.DEFAULT;\n            if (!predictions || predictions.length === 0) {\n                continue;\n            }\n\n            sortBy(predictions, (o) => o.probability);\n            const minorPrediction = predictions.slice(0, predictions.length - 1);\n            if (minorPrediction && minorPrediction.length !== 0) {\n                for (let j = 0; j < minorPrediction.length; j += 1) {\n                    const traj = minorPrediction[j];\n                    const points = traj.predictedTrajectory;\n                    if (points && points.length !== 0) {\n                        const mesh = drawSegmentsFromPoints(points, {\n                            color,\n                            linewidth: 2.3,\n                            zOffset: zOffset.prediction,\n                            opacity: 1,\n                            matrixAutoUpdate: true,\n                        });\n                        this.minorMeshs.push(mesh);\n                        this.scene.add(mesh);\n\n                        if (this.option.layerOption.Prediction.gaussianInfo) {\n                            for (let k = 0; k < points.length; k += 1) {\n                                const point = points[k];\n                                const gaussianMesh = this.drawGaussian(point.gaussianInfo, color);\n                                if (gaussianMesh) {\n                                    this.guassMeshs.push(gaussianMesh);\n                                    this.scene.add(gaussianMesh);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    disposeMajorMeshs() {\n        this.majorMeshs.forEach((mesh) => {\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n        this.majorMeshs = [];\n    }\n\n    disposeMinorMeshs() {\n        this.minorMeshs.forEach((mesh) => {\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n        this.minorMeshs = [];\n    }\n\n    disposeGaussMeshs() {\n        this.guassMeshs.forEach((mesh) => {\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n        this.guassMeshs = [];\n    }\n\n    drawGaussian(gaussian, color) {\n        if (gaussian && gaussian.ellipseA > EPSILON && gaussian.ellipseB > EPSILON) {\n            const material = new THREE.MeshBasicMaterial({\n                color,\n                transparent: true,\n                opacity: 0.5,\n            });\n            const geometry = drawEllipseGeometry(gaussian.ellipseA, gaussian.ellipseB);\n            const mesh = new THREE.Mesh(geometry, material);\n            return mesh;\n        }\n        return null;\n    }\n\n    drawCircle() {\n        const material = new THREE.MeshBasicMaterial({\n            color: 0xffffff,\n            transparent: true,\n            opacity: 0.5,\n        });\n        const circleMesh = drawCircle(0.2, material);\n        return circleMesh;\n    }\n\n    dispose() {\n        this.disposeMajorMeshs();\n        this.disposeMinorMeshs();\n        this.disposeGaussMeshs();\n    }\n}\n","export const planningParams = {\n    minInterval: 0.1,\n    defaults: {\n        width: 1.4,\n    },\n    pathProperties: {\n        default: {\n            width: 0.1,\n            color: 16764501,\n            opacity: 1,\n            zOffset: 1.4,\n        },\n        trajectory: {\n            width: 0.8,\n            color: 119233,\n            opacity: 0.65,\n            zOffset: 0.2,\n        },\n        planning_reference_line: {\n            width: 0.6,\n            color: 14177878,\n            opacity: 0.7,\n            zOffset: 1.1,\n        },\n        DpPolyPathOptimizer: {\n            width: 0.4,\n            color: 9305268,\n            opacity: 0.8,\n            zOffset: 1.2,\n        },\n        PIECEWISE_JERK_PATH_OPTIMIZER: {\n            width: 0.2,\n            color: 3580651,\n            opacity: 1,\n            zOffset: 1.3,\n        },\n        planning_path_boundary_1: {\n            style: 'dash',\n            width: 0.1,\n            color: 15793920,\n            opacity: 1,\n            zOffset: 1.3,\n        },\n        planning_path_boundary_2: {\n            style: 'dash',\n            width: 0.1,\n            color: 15793920,\n            opacity: 1,\n            zOffset: 1.3,\n        },\n    },\n};\n","import * as THREE from 'three';\nimport { union } from 'lodash';\nimport { planningParams } from '../constant/params';\nimport { disposeMesh, drawThickBandFromPoints } from '../utils/common';\nimport { drawDashedLineFromPoints } from '../utils/line';\nimport { zOffset } from '../constant/common';\n\nconst DEFAULT_WIDTH = planningParams.defaults.width;\nconst MIN_INTERVAL = planningParams.minInterval;\n\nfunction normalizePlanningTrajectory(trajectory) {\n    const result = [];\n    if (!trajectory || trajectory.length === 0) {\n        return [];\n    }\n\n    for (let i = 0; i < trajectory.length; i += 1) {\n        const point = new THREE.Vector2(trajectory[i].x, trajectory[i].y);\n        if (!point) {\n            continue;\n        }\n\n        if (result.length > 0) {\n            const lastPoint = result[result.length - 1];\n            const distance = Math.abs(lastPoint.x - point.x) + Math.abs(lastPoint.y - point.y);\n            if (distance < MIN_INTERVAL) {\n                continue;\n            }\n        }\n        result.push(point);\n    }\n    if (result.length < 2) {\n        return [];\n    }\n\n    return result;\n}\n\nexport default class Planning {\n    private scene;\n\n    private paths;\n\n    private option;\n\n    private coordinates;\n\n    constructor(scene, option, coordinates) {\n        this.scene = scene;\n        this.option = option;\n        this.coordinates = coordinates;\n        this.paths = {};\n    }\n\n    update(planningTrajectory, planningData, autoDrivingCar) {\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        let width = null;\n        if (!autoDrivingCar?.width) {\n            console.warn(\n                `Unable to get the auto driving car's width, planning line width has been set to default: ${DEFAULT_WIDTH} m.`,\n            );\n            width = DEFAULT_WIDTH;\n        } else {\n            width = autoDrivingCar.width;\n        }\n\n        const newPaths = {\n            trajectory: [],\n        };\n        if (planningTrajectory) {\n            newPaths.trajectory = planningTrajectory.map((point) => ({ x: point.positionX, y: point.positionY }));\n        }\n        if (planningData && planningData.path) {\n            planningData.path.forEach((path) => {\n                newPaths[path.name] = path.pathPoint;\n            });\n        }\n\n        const allPaths = union(Object.keys(this.paths), Object.keys(newPaths));\n        allPaths.forEach((name) => {\n            const oldPath = this.paths[name];\n            if (name === 'trajectory' && !this.option.layerOption.Planning.planningTrajectory) {\n                disposeMesh(oldPath);\n                this.scene.remove(oldPath);\n                delete this.paths[name];\n                return;\n            }\n            if (oldPath) {\n                disposeMesh(oldPath);\n                this.scene.remove(oldPath);\n                delete this.paths[name];\n            }\n\n            let property = planningParams.pathProperties[name];\n            if (!property) {\n                console.warn(`No path properties found for [${name}]. Use default properties instead.`);\n                property = planningParams.pathProperties.default;\n            }\n\n            if (newPaths[name]) {\n                let points = normalizePlanningTrajectory(newPaths[name]);\n                points = this.coordinates.applyOffsetToArray(points);\n                if (points.length === 0) {\n                    return;\n                }\n                if (property.style === 'dash') {\n                    this.paths[name] = drawDashedLineFromPoints(points, {\n                        color: property.color,\n                        linewidth: width * property.width,\n                        dashSize: 1,\n                        gapSize: 1,\n                        zOffset: property.zOffset,\n                        opacity: property.opacity,\n                        matrixAutoUpdate: true,\n                    });\n                } else {\n                    const line = drawThickBandFromPoints(points, {\n                        color: property.color,\n                        opacity: property.opacity,\n                        lineWidth: width * property.width,\n                    });\n                    if (line) {\n                        line.position.z = property.zOffset;\n                        this.paths[name] = line;\n                    }\n                }\n                this.scene.add(this.paths[name]);\n            }\n        });\n    }\n\n    dispose() {\n        Object.keys(this.paths).forEach((key) => {\n            const mesh = this.paths[key];\n            disposeMesh(mesh);\n            this.scene.remove(mesh);\n        });\n        this.paths = {};\n    }\n}\n","import * as THREE from 'three';\nimport { disposeGroup, drawCircle } from '../utils/common';\nimport { drawSegmentsFromPoints } from '../utils/line';\n\nexport default class Gps {\n    private group;\n\n    private scene;\n\n    private adc;\n\n    private option;\n\n    private coordinates;\n\n    constructor(scene, adc, option, coordinates) {\n        this.group = null;\n        this.scene = scene;\n        this.option = option;\n        this.adc = adc;\n        this.coordinates = coordinates;\n    }\n\n    update(gps) {\n        if (!this.adc?.vehicleParam) {\n            return;\n        }\n        if (!this.coordinates.isInitialized()) {\n            return;\n        }\n        if (!this.group) {\n            this.group = new THREE.Group();\n            const material = new THREE.MeshBasicMaterial({\n                color: 0x006aff,\n                transparent: true,\n                opacity: 0.5,\n            });\n            const circle = drawCircle(0.2, material);\n            const vehicleParam = this.adc.vehicleParam;\n            const points = [\n                new THREE.Vector3(vehicleParam.frontEdgeToCenter, -vehicleParam.leftEdgeToCenter, 0),\n                new THREE.Vector3(vehicleParam.frontEdgeToCenter, vehicleParam.rightEdgeToCenter, 0),\n                new THREE.Vector3(-vehicleParam.backEdgeToCenter, vehicleParam.rightEdgeToCenter, 0),\n                new THREE.Vector3(-vehicleParam.backEdgeToCenter, -vehicleParam.leftEdgeToCenter, 0),\n                new THREE.Vector3(vehicleParam.frontEdgeToCenter, -vehicleParam.leftEdgeToCenter, 0),\n            ];\n            const base = drawSegmentsFromPoints(points, {\n                color: 0x006aff,\n                linewidth: 2,\n                zOffset: 5,\n                opacity: 1,\n                matrixAutoUpdate: true,\n            });\n            this.group.add(circle);\n            this.group.add(base);\n        }\n\n        const { positionX, positionY } = gps;\n        const position = this.coordinates.applyOffset({ x: positionX, y: positionY });\n        this.group.position.set(position.x, position.y, 0.01);\n        this.group.visible = this.option.layerOption.Position.gps;\n        this.scene.add(this.group);\n    }\n\n    dispose() {\n        if (!this.group) {\n            return;\n        }\n        disposeGroup(this.group);\n        this.scene.remove(this.group);\n        this.group = null;\n    }\n}\n","interface ChildLayerVisible {\n    [key: string]: boolean;\n}\n\nexport const layerVisible: { [key: string]: ChildLayerVisible } = {\n    Perception: {\n        pointCloud: true,\n        vehicle: true,\n        pedestrian: true,\n        bicycle: true,\n        unknownMovable: true,\n        unknownUnMovable: true,\n        unknown: true,\n        cipv: true,\n        obstacleVelocity: true,\n        obstacleHeading: true,\n        obstacleId: true,\n        obstacleDistanceAndSpeed: true,\n        laneMarker: false,\n        lidarSensor: false,\n        radarSensor: false,\n        cameraSensor: false,\n        v2x: false,\n        polygon: true,\n        boundingbox: false,\n    },\n    Prediction: {\n        majorPredictionLine: true,\n        minorPredictionLine: true,\n        gaussianInfo: false,\n        obstaclePriority: true,\n        obstacleInteractiveTag: true,\n    },\n    Routing: {\n        routingLine: true,\n    },\n    Decision: {\n        mainDecision: true,\n        obstacleDecision: true,\n    },\n    Planning: {\n        planningCar: false,\n        planningTrajectory: true,\n    },\n    Position: {\n        localization: true,\n        gps: false,\n        shadow: false,\n    },\n    Map: {\n        crosswalk: true,\n        clearArea: true,\n        junction: true,\n        pncJunction: true,\n        lane: true,\n        road: false,\n        signal: true,\n        stopSign: true,\n        yieldSign: true,\n        speedBump: true,\n        parkingSpace: true,\n        laneId: false,\n        parkingSpaceId: false,\n    },\n};\n","import { layerVisible } from './layerVisible';\n\nexport default class Option {\n    public layerOption;\n\n    private key;\n\n    constructor() {\n        this.key = null;\n        this.setLayerOption();\n    }\n\n    setLayerOption = () => {\n        let result = null;\n        if (this.key) {\n            const option = localStorage.getItem(`layerOption_${this.key}`);\n            result = JSON.parse(option);\n        } else {\n            result = layerVisible;\n        }\n        this.layerOption = result;\n    };\n\n    updateLayerOption = (option, key) => {\n        this.key = key;\n        localStorage.setItem(`layerOption_${this.key}`, JSON.stringify(option));\n        this.setLayerOption();\n    };\n}\n","import * as THREE from 'three';\n\nimport { isNumber, isNaN, isArray } from 'lodash';\n\nexport default class Coordinates {\n    private offset;\n\n    constructor() {\n        this.offset = null;\n    }\n\n    isInitialized() {\n        return this.offset !== null;\n    }\n\n    initialize(x, y) {\n        if (!isNumber(x) || !isNumber(y)) {\n            console.warn('Skip setting invalid offset:', x, y);\n            return;\n        }\n\n        this.offset = {\n            x,\n            y,\n        };\n        console.log(`Offset is set to x:${x}, y:${y}`);\n    }\n\n    applyOffset(point, reverse = false) {\n        if (this.offset === null) {\n            console.error('Offset is not set.');\n            return null;\n        }\n        if (isNaN(this.offset.x) || isNaN(this.offset.y)) {\n            console.error('Offset contains NaN!');\n            return null;\n        }\n        if (isNaN(point.x) || isNaN(point.y)) {\n            console.warn('Point contains NaN!');\n            return null;\n        }\n        if (!isNaN(point.z)) {\n            return new THREE.Vector3(\n                reverse ? point.x + this.offset.x : point.x - this.offset.x,\n                reverse ? point.y + this.offset.y : point.y - this.offset.y,\n                point.z,\n            );\n        }\n\n        return new THREE.Vector2(\n            reverse ? point.x + this.offset.x : point.x - this.offset.x,\n            reverse ? point.y + this.offset.y : point.y - this.offset.y,\n        );\n    }\n\n    applyOffsetToArray(points) {\n        if (!isArray(points)) {\n            return null;\n        }\n        return points.map((point) => this.applyOffset(point));\n    }\n}\n","import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport View from './render/view';\nimport Map from './render/map';\nimport Adc from './render/adc';\nimport Obstacles from './render/obstacles';\nimport Text from './render/text';\nimport PointCloud from './render/pointCloud';\nimport Routing from './render/routing';\nimport Decision from './render/decision';\nimport Prediction from './render/prediction';\nimport Planning from './render/planning';\nimport Gps from './render/gps';\nimport Option from './option';\nimport Coordinates from './render/coordinates';\nimport { cameraParams } from './constant/common';\n\nexport default class Carviz {\n    private canvasId;\n\n    private canvasDom;\n\n    private width;\n\n    private height;\n\n    public scene;\n\n    public renderer;\n\n    public camera;\n\n    public controls;\n\n    public option;\n\n    public view;\n\n    public text;\n\n    public map;\n\n    public adc;\n\n    public obstacles;\n\n    public pointCloud;\n\n    public routing;\n\n    public decision;\n\n    public prediction;\n\n    public planning;\n\n    public gps;\n\n    private initialized;\n\n    private coordinates;\n\n    constructor(id) {\n        this.canvasId = id;\n        this.initialized = false;\n    }\n\n    render() {\n        if (this.initialized) {\n            this.view?.setView();\n            this.renderer.render(this.scene, this.camera);\n        }\n    }\n\n    updateDimention() {\n        this.camera.aspect = this.width / this.height;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(this.width, this.height);\n        this.render();\n    }\n\n    initDom() {\n        this.canvasDom = document.getElementById(this.canvasId);\n        if (!this.canvasDom || !this.canvasId) {\n            throw new Error('no canvas container');\n        }\n        this.width = this.canvasDom.clientWidth;\n        this.height = this.canvasDom.clientHeight;\n    }\n\n    initThree() {\n        this.scene = new THREE.Scene();\n\n        this.renderer = new THREE.WebGLRenderer({\n            alpha: true,\n            antialias: true,\n        });\n        this.renderer.setPixelRatio(window.devicePixelRatio);\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.renderer.setClearColor(0x0f1014);\n        this.canvasDom.appendChild(this.renderer.domElement);\n\n        this.camera = new THREE.PerspectiveCamera(\n            cameraParams.Default.fov,\n            this.width / this.height,\n            cameraParams.Default.near,\n            cameraParams.Default.far,\n        );\n        this.camera.up.set(0, 0, 1);\n\n        const light = new THREE.DirectionalLight(0xffeedd);\n        light.position.set(0, 0, 10);\n        this.scene.add(light);\n\n        this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n        this.controls.enabled = false;\n        this.controls.keys = {\n            LEFT: 'ArrowLeft',\n            UP: 'ArrowUp',\n            RIGHT: 'ArrowRight',\n            BOTTOM: 'ArrowDown',\n        };\n        this.controls.listenToKeyEvents(window);\n        this.controls.addEventListener('change', () => {\n            this.view?.setView();\n            this.render();\n        });\n        this.controls.keys = {\n            LEFT: 'ArrowLeft',\n            UP: 'ArrowUp',\n            RIGHT: 'ArrowRight',\n            BOTTOM: 'ArrowDown',\n        };\n        this.controls.mouseButtons = {\n            LEFT: THREE.MOUSE.ROTATE,\n            MIDDLE: THREE.MOUSE.DOLLY,\n            RIGHT: THREE.MOUSE.PAN,\n        };\n        this.updateDimention();\n        const resizeObserver = new ResizeObserver(() => {\n            this.width = this.canvasDom?.clientWidth;\n            this.height = this.canvasDom?.clientHeight;\n            this.updateDimention();\n        });\n        resizeObserver.observe(this.canvasDom);\n        this.render();\n    }\n\n    initModule() {\n        this.coordinates = new Coordinates();\n        this.option = new Option();\n        this.adc = new Adc(this.scene, this.option, this.coordinates);\n        this.view = new View(this.camera, this.controls, this.adc);\n        this.text = new Text(this.camera);\n        this.map = new Map(this.scene, this.text, this.option, this.coordinates);\n        this.obstacles = new Obstacles(this.scene, this.view, this.text, this.option, this.coordinates);\n        this.pointCloud = new PointCloud(this.scene, this.adc, this.option);\n        this.routing = new Routing(this.scene, this.option, this.coordinates);\n        this.decision = new Decision(this.scene, this.option, this.coordinates);\n        this.prediction = new Prediction(this.scene, this.option, this.coordinates);\n        this.planning = new Planning(this.scene, this.option, this.coordinates);\n        this.gps = new Gps(this.scene, this.adc, this.option, this.coordinates);\n    }\n\n    init() {\n        this.initDom();\n        this.initThree();\n        this.initModule();\n        this.initialized = true;\n    }\n\n    updateData(datas) {\n        if (datas instanceof Object) {\n            const dataKeys = Object.keys(datas);\n            dataKeys.forEach((key) => {\n                const data = datas[key];\n                switch (key) {\n                    case 'autoDrivingCar':\n                        this.adc.update(data, 'adc');\n                        break;\n                    case 'map':\n                        this.map.update(data, false);\n                        break;\n                    case 'pointCloud':\n                        this.pointCloud.update(data);\n                        break;\n                    case 'shadowLocalization':\n                        this.adc.update(data, 'shadowAdc');\n                        break;\n                    case 'planningData':\n                        this.adc.update(data.initPoint?.pathPoint, 'planningAdc');\n                        break;\n                    case 'mainDecision':\n                        this.decision.updateMainDecision(data);\n                        break;\n                    case 'object':\n                        this.decision.updateObstacleDecision(data);\n                        this.obstacles.update(data, datas.sensorMeasurements, datas.autoDrivingCar);\n                        this.prediction.update(data);\n                        break;\n                    case 'gps':\n                        this.gps.update(data);\n                        break;\n                    case 'planningTrajectory':\n                        this.planning.update(data, datas.planningData, datas.autoDrivingCar);\n                        break;\n                    case 'routePath':\n                        this.routing.update(datas.routingTime, data);\n                        break;\n                    default:\n                        break;\n                }\n            });\n        }\n    }\n\n    removeAll() {\n        this.map.dispose();\n        this.obstacles.dispose();\n        this.pointCloud.dispose();\n        this.routing.dispose();\n        this.decision.dispose();\n        this.prediction.dispose();\n        this.planning.dispose();\n        this.gps.dispose();\n    }\n\n    removeMap() {\n        this.map.dispose();\n    }\n\n    removeObstacles() {\n        this.obstacles.dispose();\n    }\n\n    removePointCloud() {\n        this.pointCloud.dispose();\n    }\n\n    removeRouting() {\n        this.routing.dispose();\n    }\n\n    removeDecision() {\n        this.decision.dispose();\n    }\n\n    removePrediction() {\n        this.prediction.dispose();\n    }\n\n    removePlanning() {\n        this.planning.dispose();\n    }\n\n    removeGps() {\n        this.gps.dispose();\n    }\n}\n","import React from 'react';\nimport { IconIcAmplification, IconIcReduce } from '@dreamview/dreamview-ui';\nimport useStyle from '../useStyle';\n\nexport default function ViewMenu(props: any) {\n    const { carviz } = props;\n    const { classes } = useStyle();\n    return (\n        <div className={classes['view-menu-btn-container']}>\n            <div className={classes['view-menu-btn-item']} onClick={() => carviz.view?.updateViewDistance(-10)}>\n                <IconIcAmplification style={{ fontSize: '16px', color: '#96A5C1' }} />\n            </div>\n            <div className={classes['view-menu-btn-item']} onClick={() => carviz.view?.updateViewDistance(10)}>\n                <IconIcReduce style={{ fontSize: '16px', color: '#96A5C1' }} />\n            </div>\n        </div>\n    );\n}\n","import React, { useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport useStyle from '../useStyle';\n\nexport default function ViewMenu(props: any) {\n    const { carviz, setCurrentView } = props;\n    const { classes, cx } = useStyle();\n    const [view, setView] = useState('Default');\n    const changeView = (viewType: string) => {\n        setView(viewType);\n        carviz.view.changeViewType(viewType);\n        setCurrentView(viewType.charAt(0));\n    };\n    const { t } = useTranslation('viewMenu');\n\n    return (\n        <div className={classes['view-menu-container']}>\n            <div className={classes['view-menu-header']}>{t('switchViews')}</div>\n            <div\n                className={cx(classes['view-menu-item'], {\n                    [classes['view-menu-active']]: view === 'Default',\n                })}\n                onClick={() => changeView('Default')}\n            >\n                {t('default')}\n            </div>\n            <div\n                className={cx(classes['view-menu-item'], {\n                    [classes['view-menu-active']]: view === 'Near',\n                })}\n                onClick={() => changeView('Near')}\n            >\n                {t('near')}\n            </div>\n            <div\n                className={cx(classes['view-menu-item'], {\n                    [classes['view-menu-active']]: view === 'Overhead',\n                })}\n                onClick={() => changeView('Overhead')}\n            >\n                {t('overhead')}\n            </div>\n            <div\n                className={cx(classes['view-menu-item'], {\n                    [classes['view-menu-active']]: view === 'Map',\n                })}\n                onClick={() => changeView('Map')}\n            >\n                {t('map')}\n            </div>\n        </div>\n    );\n}\n","// \nexport const isMac = (): boolean => /macintosh|mac os x/i.test(navigator.userAgent);\nexport const isWin = (): boolean => {\n    const agent = navigator.userAgent.toLowerCase();\n    return agent.indexOf('win32') >= 0 || agent.indexOf('win64') >= 0;\n};\n"],"names":["colorMapping","zOffset","obstacleColorMapping","PEDESTRIAN","BICYCLE","VEHICLE","VIRTUAL","CIPV","DEFAULT","TRAFFICCONE","UNKNOWN","UNKNOWN_MOVABLE","UNKNOWN_UNMOVABLE","pointCloudHeightColorMapping","decisionMarkerColorMapping","STOP","FOLLOW","YIELD","OVERTAKE","mainDecisionStopReasonMarkerMapping","STOP_REASON_HEAD_VEHICLE","STOP_REASON_DESTINATION","STOP_REASON_PEDESTRIAN","STOP_REASON_OBSTACLE","STOP_REASON_SIGNAL","STOP_REASON_STOP_SIGN","STOP_REASON_YIELD_SIGN","STOP_REASON_CLEAR_ZONE","STOP_REASON_CROSSWALK","STOP_REASON_EMERGENCY","STOP_REASON_NOT_READY","STOP_REASON_PULL_OVER","mainDecisionChangeLaneMarkerMapping","LEFT","RIGHT","decisionFenceMapping","fenceObjectStop","fenceObjectFollow","fenceObjectYield","fenceObjectOvertake","MAIN_STOP","obstacleDecisionIconMapping","iconObjectYield","cameraParams","Default","fov","near","far","Near","Overhead","Map","View","camera","controls","adc","_classCallCheck","this","defaultViewDistance","nearViewDistance","overheadViewDistance","mapViewDistance","viewAngle","key","value","distance","angle","type","viewType","_this$adc","target","_ref","position","_ref$x","x","_ref$y","y","_ref$z","z","rotationY","rotation","offsetX","concat","lowerFirst","Math","cos","offsetY","sin","offsetZ","set","up","lookAt","enabled","target0","THREE","position0","clone","zoom0","zoom","enabledRotate","reset","updateProjectionMatrix","offset","curDistance","newDistance","min","max","setView","setViewType","drawDashedLineFromPoints","points","lineAttr","_lineAttr$color","color","_lineAttr$linewidth","linewidth","_lineAttr$dashSize","dashSize","_lineAttr$gapSize","gapSize","_lineAttr$zOffset","_lineAttr$opacity","opacity","_lineAttr$matrixAutoU","matrixAutoUpdate","geometry","setFromPoints","material","transparent","mesh","computeLineDistances","updateMatrix","drawDashedLineFromPointsClone","drawSegmentsFromPointsClone","drawSegmentsFromPoints","_lineAttr$color2","_lineAttr$linewidth2","_lineAttr$zOffset2","_lineAttr$opacity2","_lineAttr$matrixAutoU2","coordinatesSame","coord1","coord2","disposeMesh","_mesh$geometry","_mesh$material","dispose","disposeGroup","group","traverse","child","drawCircle","radius","segments","arguments","length","undefined","drawArrow","conelength","conewidth","end","drawImge","img","width","height","textLoader","map","load","depthWrite","side","drawThickBandFromPoints","thickAttr","_thickAttr$color","_thickAttr$opacity","_thickAttr$lineWidth","lineWidth","line","MeshLine","setGeometry","MeshLineMaterial","drawShapeFromPoints","shape","Lane","scene","text","option","coordinates","laneGroupMap","laneIdMeshMap","drawedLaneIds","currentLaneIds","xmax","xmin","Infinity","ymin","ymax","center","dottedYellowLineDashedMaterialTemplate","dottedWhiteLineDashedMaterialTemplate","solidYellowLineBasicMaterialTemplate","solidWhiteLineBasicMaterialTemplate","curbLineBasicMaterialTemplate","centerLineBasicMaterialTemplate","laneType","left","right","add","defaultLineBasicMaterialTemplate","lanes","_this","layerOption","laneId","disposeLaneIds","isInitialized","forEach","lane","id","push","drawLaneId","name","centralCurve","segment","applyOffsetToArray","lineSegment","point","p","centerLine","rightLaneType","rightBoundary","boundaryType","types","curve","boundary","drawLaneMesh","leftLaneType","leftBoundary","removeOldLanes","_centerLine$","_centerLine$0$lineSeg","applyOffset","startPosition","rotationZ","p1","p2","atan2","textMesh","drawText","disposeLanes","_this2","Object","keys","remove","_this$text","_this3","_this4","needRemovedLaneIds","without","apply","_toConsumableArray","removedGroup","drawPolygon","polygonAttr","_polygonAttr$color","_polygonAttr$linewidt","_polygonAttr$zOffset","_polygonAttr$opacity","_polygonAttr$matrixAu","Error","Junction","meshs","currentJunctionIds","junctions","junction","polygon","junctionMesh","removeOldJunctions","values","needRemovedIds","Grid","size","gidAttr","divisions","_gidAttr$colorCenterL","colorCenterLine","_gidAttr$colorGrid","colorGrid","gridHelper","rotateX","PI","drawZone","zoneAttr","_zoneAttr$color","_zoneAttr$zOffset","_zoneAttr$opacity","_zoneAttr$matrixAutoU","zoneMesh","ClearArea","groups","currentIds","clearAreas","clearArea","lineMesh","removeOldGroups","crosswalks","crosswalk","PncJunction","pncJunctions","pncJunction","pncJunctionGroup","Road","roadMap","currentRoadIds","roads","road","section","outerPolygon","edge","item","needRemovedRoadIds","drawStopLine","stopLine","_stopLine$segment","getHeadingFromStopLine","_stopLine$segment$","NaN","stopLineDirection","getPositionAndHeading","signal","locations","heading","subsignal","location","_signal$boundary","console","warn","_signal$stopLine$","boundaryPoints","boundary1","boundary2","boundary3","orthogonalX","orthogonalY","orthogonalConstant","stopLinePoints","len","stopLineX","stopLineY","stopLineConstant","abs","intersectX","intersectY","direction","getHeadingFromStopLineAndTrafficLightBoundary","Number","isNaN","meanBy","l","STOP_SIGN_SCALE","YieldSignal","yieldSignTemplate","yieldLineMeshs","yieldSignMeshs","currentYieldgnalIds","iniYieldSignTemplate","yieldSign","_yieldSign$stopLine","_yieldSign$stopLine2","stopLinePoint","mtlLoader","MTLLoader","objLoader","OBJLoader","yieldSignMaterial","preload","setMaterials","yieldSignObj","object","yieldSigns","_this2$getPositionAnd","scale","removeOldTrafficSignals","drawedStopSignalIds","needRemovedStopSignals","removedSignal","_regeneratorRuntime","e","t","r","prototype","n","hasOwnProperty","o","defineProperty","i","Symbol","a","iterator","c","asyncIterator","u","toStringTag","define","enumerable","configurable","writable","wrap","Generator","create","Context","makeInvokeMethod","tryCatch","arg","call","h","f","s","GeneratorFunction","GeneratorFunctionPrototype","d","getPrototypeOf","v","g","defineIteratorMethods","_invoke","AsyncIterator","invoke","_typeof","resolve","__await","then","callInvokeWithMethodAndArg","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","displayName","isGeneratorFunction","constructor","mark","setPrototypeOf","__proto__","awrap","async","Promise","reverse","pop","prev","charAt","slice","stop","rval","handle","complete","finish","delegateYield","_unsupportedIterableToArray","minLen","_arrayLikeToArray","toString","Array","from","test","arr","arr2","asyncGeneratorStep","gen","reject","_next","_throw","info","error","_defineProperties","props","descriptor","input","hint","prim","toPrimitive","res","String","_toPrimitive","SUBSIGNAL_TO_INDEX","GREEN","YELLOW","RED","SUBSIGNAL_TO_LIGHT","TrafficSignal","instance","Constructor","trafficBaseMeshTemplate","trafficMaterials","baseSignalMeshs","signalStatusMeshs","currentTrafficSignalIds","stopLineMeshs","initTrafficTemplate","protoProps","getLightMaterial","originMaterial","lightMaterial","emissive","trafficLightMaterial","fn","_callee","materials","_materials$getAsArray","_materials$getAsArray2","DARK_GREEN","DARK_YELLOW","DARK_RED","_context","getAsArray","isArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","DARK","LIGHT","trafficLightObject","self","args","err","_x","signals","clearSignalStatus","trafficSignalCurMapping","currentSignal","index","subsignalMesh","children","_this5","darkMaterial","_this6","drawedTrafficSignalIds","needRemovedTrafficSignals","StopSign","stopSignTemplate","stopSignMeshs","currentStopSignalIds","initStopSignTemplate","stopSign","_stopSign$stopLine","_stopSign$stopLine2","stopSignMaterial","stopSignObj","stopSigns","SpeedBump","speedBumps","speedBump","lines","ParkingSpace","ids","parkingSpaces","parkingSpace","parkingSpaceId","drawParkingSpaceId","_parkingSpace$polygon","point1","point2","point3","disposeParkingSpaceIds","disposeParkingSpaces","removedMesh","trafficSignal","yieldSignal","Crosswalk","grid","mapData","removeOld","data","_this$option$layerOpt","drawLanes","drawJunctions","drawCrosswalk","drawClearAreas","drawPncJunctions","drawRoads","drawYieldSigns","drawTrafficSignals","drawStopSigns","drawSpeedBumps","drawParkingSpaces","_this$lane","drawGrid","updateTrafficStatus","Adc","shadowAdc","planningAdc","autoDrivingCar","vehicleParam","frontEdgeToCenter","backEdgeToCenter","leftEdgeToCenter","rightEdgeToCenter","steerRatio","wheelBase","init","carObject","visible","carMaterial","pos","isNumber","positionX","positionY","initialize","Position","localization","shadow","Planning","planningCar","params","resizeCarSize","_this$shadowAdc","_this$planningAdc","DEFAULT_HEIGHT","ObjectType","Obstacles","view","obstacleMeshs","speedHeadingArrows","obstacleHeadingArrows","textMeshs","iconMeshs","iconMeshTemplate","solidFaceCubeMeshTemplate","drawIconMeshTemplate","drawCubeTemplate","obstacle","arrowMesh","rotateZ","speedHeading","speed","log2","positionZ","obstacles","measurements","updateObstacles","updateSensorMeasurements","Perception","obstacleHeading","obstacleDistanceAndSpeed","yieldedobstacle","camelCase","drawObstacle","obstacleHeadingArrow","drawObstacleHeading","speedHeadingArrow","drawSpeedHeading","icon","drawTexts","sensorMeasurements","_this$option$layerOpt2","lidar","radar","_sensorMeasurements$k","sensorType","search","getSensorType","toLowerCase","sensorMeasurement","box","solidFaceCube","ouline","shadowSide","depthTest","addOutLineToObject","polygonPoint","confidence","source","bottomPoints","dashMaterial","isV2x","bottomGeometry","bottomFace","topPoints","topGeometry","topFace","segmentMesh","solidTopPoints","solidTopGeometry","solidTopFace","dashTopPoints","dashTopGeometry","dashTopFace","subType","drawTrafficCone","drawObstaclePolygon","boundingbox","drawV2xCube","drawCube","v2XCubeMesh","setHex","_obstacle$confidence","solidBox","drawBox","dashBox","dashedLine","drawDashedBox","_this$option$layerOpt3","obstacleId","obstaclePriority","obstacleInteractiveTag","v2x","isBirdView","adcX","adcY","adcHeading","adcPosition","obstaclePosition","initPosition","deltaX","deltaY","deltaZ","lineCount","distanceTo","toFixed","speedAndDistanceText","idPosition","idText","_obstacle$obstaclePri","priority","priorityPosition","priorityText","_obstacle$interactive","interactiveTag","interactiveTagPosition","interactiveTagText","_obstacle$v2xInfo","v2xType","v2xInfo","v2xTypePosition","v2xTypeText","fonts","font","FontLoader","parse","fontJson","gentilis_bold","Text3D","charMeshes","charPointers","charWidths","composeText","quaternion","copy","charIndices","charCodeAt","offsetSum","j","idx","pIdx","_this$drawChar3D","drawChar3D","charMesh","charWidth","isFinite","setX","char","charGeo","TextGeometry","charMaterial","computeBoundingBox","_charGeo$boundingBox","boundingBox","MAX_POINTS","PointCloud","pointCloudMesh","pointCloud","_adcMesh$rotation","num","adcMesh","_adcMesh$position","_adcMesh$position$x","_adcMesh$position$y","pointCloudSize","total","colorKey","positions","colors","b","setAttribute","vertexColors","Routing","routePathMeshs","lastRoutingTime","routingTime","routePath","routingLine","path","pathMesh","Decision","fenceMeshMapping","iconMeshMapping","mainChangeLaneMeshMapping","mainStopReasonMeshMapping","mainDecisionGroups","obstacleDecisionGroupsAndMeshs","initFenceMesh","initIconMesh","initMainStopReasonMesh","initMainChangeLaneMesh","mainDecision","mainDecisionVisible","obstacleDecisionVisible","obstacleDecision","disposeMainDecisionMeshs","disposeObstacleDecisionMeshs","updateMainDecision","updateObstacleDecision","decision","dec","stopReason","changeLaneType","fence","decisions","nudgeMesh","Prediction","majorMeshs","minorMeshs","guassMeshs","majorPredictionLine","minorPredictionLine","updateMajorPrediction","updateMinorPrediction","predictions","prediction","sortBy","probability","majorPrediction","predictedTrajectory","circleMesh","gaussianInfo","gaussianMesh","drawGaussian","minorPrediction","k","gaussian","ellipseA","ellipseB","aRadius","bRadius","absellipse","disposeMajorMeshs","disposeMinorMeshs","disposeGaussMeshs","planningParams","minInterval","defaults","pathProperties","default","trajectory","planning_reference_line","DpPolyPathOptimizer","PIECEWISE_JERK_PATH_OPTIMIZER","planning_path_boundary_1","style","planning_path_boundary_2","DEFAULT_WIDTH","MIN_INTERVAL","paths","planningTrajectory","planningData","newPaths","pathPoint","union","oldPath","property","result","lastPoint","normalizePlanningTrajectory","Gps","gps","circle","base","layerVisible","vehicle","pedestrian","bicycle","unknownMovable","unknownUnMovable","unknown","cipv","obstacleVelocity","laneMarker","lidarSensor","radarSensor","cameraSensor","Option","_createClass","_defineProperty","localStorage","getItem","JSON","setItem","stringify","setLayerOption","Coordinates","log","Carviz","canvasId","initialized","_this$view","renderer","render","aspect","setSize","canvasDom","document","getElementById","clientWidth","clientHeight","alpha","antialias","setPixelRatio","window","devicePixelRatio","innerWidth","innerHeight","setClearColor","appendChild","domElement","light","OrbitControls","UP","BOTTOM","listenToKeyEvents","addEventListener","_this$view2","mouseButtons","ROTATE","MIDDLE","DOLLY","PAN","updateDimention","ResizeObserver","_this$canvasDom","_this$canvasDom2","observe","Text","routing","planning","initDom","initThree","initModule","datas","_data$initPoint","update","initPoint","ViewMenu","carviz","classes","useStyle","React","className","onClick","_carviz$view","updateViewDistance","IconIcAmplification","fontSize","_carviz$view2","IconIcReduce","setCurrentView","_useStyle","cx","_useState2","useState","changeView","changeViewType","useTranslation","isMac","navigator","userAgent","isWin","agent","indexOf"],"sourceRoot":""}